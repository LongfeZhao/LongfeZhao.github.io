<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>求前缀表达式的值</title>
    <url>/2020/03/11/%E6%B1%82%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>算术表达式有前缀表示法、中缀表示法和后缀表示法等形式。前缀表达式指二元运算符位于两个运算数之前，例如2+3*(7-4)+8/4的前缀表达式是：+ + 2 * 3 - 7 4 / 8 4。请设计程序计算前缀表达式的结果值。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入在一行内给出不超过30个字符的前缀表达式，只包含+、-、*、/以及运算数，不同对象（运算数、运算符号）之间以空格分隔。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出前缀表达式的运算结果，保留小数点后1位，或错误信息ERROR。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ + 2 * 3 - 7 4 &#x2F; 8 4</span><br></pre></td></tr></table></figure>

<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13.0</span><br></pre></td></tr></table></figure>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">calculate</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">char</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (t) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="keyword">return</span> x - y;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">        <span class="keyword">return</span> x * y;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">0.0</span>) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"ERROR"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x / y;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">solve</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">float</span>&gt; S;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = str[i];</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">' '</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s != <span class="string">""</span>) &#123;</span><br><span class="line">                reverse(s.begin(), s.end());</span><br><span class="line">                S.push(stof(s));</span><br><span class="line">                s = <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c) || (c == <span class="string">'-'</span> &amp;&amp; s != <span class="string">""</span>)) &#123;</span><br><span class="line">            s += c;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.empty()) &#123;</span><br><span class="line">                reverse(s.begin(), s.end());</span><br><span class="line">                <span class="keyword">return</span> stof(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">float</span> a = S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            <span class="keyword">float</span> b = S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            S.push(calculate(a, b, c));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S.top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    getline(<span class="built_in">cin</span>, str);</span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'+'</span>) &#123;</span><br><span class="line">        <span class="built_in">string</span>::size_type it = str.find(<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="built_in">string</span>::npos) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.1f"</span>, stof(str));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span> ans = solve(str);</span><br><span class="line">    <span class="keyword">if</span> (ans != <span class="number">0.0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.1f\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔问题</title>
    <url>/2019/12/20/%E6%B1%89%E8%AF%BA%E5%A1%94/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>借助堆栈以非递归（循环）方式求解汉诺塔的问题（n, a, b, c），即将N个盘子从起始柱（标记为“a”）通过借助柱（标记为“b”）移动到目标柱（标记为“c”），并保证每个移动符合汉诺塔问题的要求。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入为一个正整数N，即起始柱上的盘数。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>每个操作（移动）占一行，按柱1 -&gt; 柱2的格式输出。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a -&gt; c</span><br><span class="line">a -&gt; b</span><br><span class="line">c -&gt; b</span><br><span class="line">a -&gt; c</span><br><span class="line">b -&gt; a</span><br><span class="line">b -&gt; c</span><br><span class="line">a -&gt; c</span><br></pre></td></tr></table></figure>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"%c -&gt; %c\n"</span>, a, b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hanoi</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> a, <span class="keyword">char</span> b, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        move(a, c);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        hanoi(n - <span class="number">1</span>, a, c, b);</span><br><span class="line">        move(a, c);</span><br><span class="line">        hanoi(n - <span class="number">1</span>, b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    hanoi(n, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>关键活动</title>
    <url>/2019/12/19/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>假定一个工程项目由一组子任务构成，子任务之间有的可以并行执行，有的必须在完成了其它一些子任务后才能执行。“任务调度”包括一组子任务、以及每个子任务可以执行所依赖的子任务集。</p>
<p>比如完成一个专业的所有课程学习和毕业设计可以看成一个本科生要完成的一项工程，各门课程可以看成是子任务。有些课程可以同时开设，比如英语和C程序设计，它们没有必须先修哪门的约束；有些课程则不可以同时开设，因为它们有先后的依赖关系，比如C程序设计和数据结构两门课，必须先学习前者。</p>
<p>但是需要注意的是，对一组子任务，并不是任意的任务调度都是一个可行的方案。比如方案中存在“子任务A依赖于子任务B，子任务B依赖于子任务C，子任务C又依赖于子任务A”，那么这三个任务哪个都不能先执行，这就是一个不可行的方案。</p>
<p>任务调度问题中，如果还给出了完成每个子任务需要的时间，则我们可以算出完成整个工程需要的最短时间。在这些子任务中，有些任务即使推迟几天完成，也不会影响全局的工期；但是有些任务必须准时完成，否则整个项目的工期就要因此延误，这种任务就叫“关键活动”。</p>
<p>请编写程序判定一个给定的工程项目的任务调度是否可行；如果该调度方案可行，则计算完成整个工程项目需要的最短时间，并输出所有的关键活动。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出两个正整数N(≤100)和M，其中N是任务交接点（即衔接相互依赖的两个子任务的节点，例如：若任务2要在任务1完成后才开始，则两任务之间必有一个交接点）的数量。交接点按1<del>N编号，M是子任务的数量，依次编号为1</del>M。随后M行，每行给出了3个正整数，分别是该任务开始和完成涉及的交接点编号以及该任务所需的时间，整数间用空格分隔。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>如果任务调度不可行，则输出0；否则第1行输出完成整个工程项目需要的时间，第2行开始输出所有关键活动，每个关键活动占一行，按格式“V-&gt;W”输出，其中V和W为该任务开始和完成涉及的交接点编号。关键活动输出的顺序规则是：任务开始的交接点编号小者优先，起点编号相同时，与输入时任务的顺序相反。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 8</span><br><span class="line">1 2 4</span><br><span class="line">1 3 3</span><br><span class="line">2 4 5</span><br><span class="line">3 4 3</span><br><span class="line">4 5 1</span><br><span class="line">4 6 6</span><br><span class="line">5 7 5</span><br><span class="line">6 7 2</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">17</span><br><span class="line">1-&gt;2</span><br><span class="line">2-&gt;4</span><br><span class="line">4-&gt;6</span><br><span class="line">6-&gt;7</span><br></pre></td></tr></table></figure>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; G[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> ve[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> vl[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> in[<span class="number">105</span>];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        Node t;</span><br><span class="line">        t.id = b;</span><br><span class="line">        t.len = c;</span><br><span class="line">        G[a].push_back(t);</span><br><span class="line">        in[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">tp_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ve, <span class="number">0</span>, <span class="keyword">sizeof</span>(ve));</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!in[i]) &#123;</span><br><span class="line">            Q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        S.push(t);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)G[t].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = G[t][i].id;</span><br><span class="line">            <span class="keyword">if</span> (--in[id] == <span class="number">0</span>)</span><br><span class="line">                Q.push(id);</span><br><span class="line">            <span class="keyword">if</span> (ve[t] + G[t][i].len &gt; ve[id])</span><br><span class="line">                ve[id] = ve[t] + G[t][i].len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">int</span>)S.size() == n) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_path</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tp_sort()) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Max = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        Max = max(Max, ve[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    fill(vl, vl + n + <span class="number">1</span>, Max);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Max);</span><br><span class="line">    <span class="keyword">while</span> (!S.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = S.top();</span><br><span class="line">        S.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)G[t].size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = G[t][i].id;</span><br><span class="line">            <span class="keyword">if</span> (vl[id] - G[t][i].len &lt; vl[t])</span><br><span class="line">                vl[t] = vl[id] - G[t][i].len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = G[i].size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = G[i][j].id;</span><br><span class="line">            <span class="keyword">int</span> e = ve[i];</span><br><span class="line">            <span class="keyword">int</span> l = vl[id] - G[i][j].len;</span><br><span class="line">            <span class="keyword">if</span> (e == l) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d-&gt;%d\n"</span>, i, id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read();</span><br><span class="line">    get_path();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>栈</tag>
        <tag>图</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>部分置信区间总结</title>
    <url>/2019/12/09/%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
<meta name="generator" content="Hexo 4.2.0"></head>
## 正态总体参数置信区间

<ol>
<li><p>单正态分布均值μ</p>
<ul>
<li><p>σ<sup>2</sup>已知<br>$$<br>(\bar X-\frac{\sigma}{\sqrt{n}}z_{\frac \alpha 2},\bar X+\frac{\sigma}{\sqrt{n}}z_{\frac \alpha 2})<br>$$</p>
</li>
<li><p>σ<sup>2</sup>未知，样本方差S<sup>2</sup><br>$$<br>(\bar X-\frac{S}{\sqrt n}t_\frac \alpha 2 (n-1),\bar X+\frac{S}{\sqrt n}t_\frac \alpha 2 (n-1))<br>$$</p>
</li>
</ul>
</li>
<li><p>单正态分布方差σ<sup>2</sup></p>
<ul>
<li><p>μ已知<br>$$<br>(\frac{\sum_{i=1}^n(X_i-\mu)^2}{\chi_{\frac \alpha 2}^2(n)},\frac{\sum_{i=1}^n(X_i-\mu)^2}{\chi_{1-\frac \alpha 2}^2(n)})<br>$$</p>
</li>
<li><p>μ未知，样本方差S<sup>2</sup>已知<br>$$<br>(\frac {(n-1)S^2}{\chi _{\frac \alpha 2}^2(n-1)},\frac {(n-1)S^2}{\chi _{1-\frac \alpha 2}^2(n-1)})<br>$$</p>
</li>
</ul>
</li>
<li><p>双正态分布μ<sub>1</sub>-μ<sub>2</sub></p>
<ul>
<li><p>σ<sub>1</sub><sup>2</sup>, σ<sub>2</sub><sup>2</sup>已知<br>$$<br>(\bar X-\bar Y\pm\sqrt{\frac {\sigma_1^2} {n_1} +\frac {\sigma_2^2} {n_2} }z_{\frac \alpha 2})<br>$$</p>
</li>
<li><p>σ<sub>1</sub><sup>2</sup>= σ<sub>2</sub><sup>2</sup>未知<br>$$<br>(\bar X-\bar Y\pm S_w\sqrt{\frac 1 {n_1}+\frac 1 {n_2}}t_{\frac \alpha 2}(n_1+n_2-2))<br>$$<br>其中<br>$$<br>S_w=\sqrt{\frac {(n_1-1)S_1^2+(n_2-1)S_2^2}{n_1+n_2-2}}<br>$$</p>
</li>
</ul>
</li>
<li><p>双正态分布σ<sub>1</sub><sup>2</sup> / σ<sub>2</sub><sup>2</sup></p>
<ul>
<li><p>μ<sub>1</sub>，μ<sub>2</sub>已知<br>$$<br>(\frac {n_2\sum_{i=1}^{n_1}(X_i-\mu_1)^2} {n_1\sum_{i=1}^{n_1}(Y_i-\mu_2)^2}\frac 1 {F_{\frac \alpha 2}(n_1,n_2)},\frac {n_2\sum_{i=1}^{n_1}(X_i-\mu_1)^2} {n_1\sum_{i=1}^{n_1}(Y_i-\mu_2)^2}F_{\frac \alpha 2}(n_2,n_1))<br>$$</p>
</li>
<li><p>μ<sub>1</sub>，μ<sub>2</sub>未知<br>$$<br>(\frac{S_1^2}{S_2^2}\frac 1 {F_{\frac \alpha 2(n_1-1,n_2-1)}},\frac{S_1^2}{S_2^2} {F_{\frac \alpha 2(n_2-1,n_1-1)}})<br>$$</p>
</li>
</ul>
</li>
</ol>
<h3 id="0-1分布总体参数的置信区间"><a href="#0-1分布总体参数的置信区间" class="headerlink" title="0 - 1分布总体参数的置信区间"></a>0 - 1分布总体参数的置信区间</h3><ul>
<li>X~B(1, p), 参数p的置信水平为1-α的置信区间<br>$$<br>(\frac 1{2a}(-b-\sqrt{ b^2-4ac}),\frac 1{2a}(-b+\sqrt{ b^2-4ac}))<br>$$</li>
</ul>
<p>  其中<br>  $$<br>  a = n+z_{\frac \alpha 2}^2, b= -(2n\bar X+z_{\frac \alpha 2}^2),c=n\bar X^2<br>  $$</p>
]]></content>
      <tags>
        <tag>概率论与数理统计</tag>
      </tags>
  </entry>
  <entry>
    <title>哥尼斯堡七桥问题</title>
    <url>/2019/12/08/%E5%93%A5%E5%B0%BC%E6%96%AF%E5%A0%A1%E7%9A%84%E2%80%9C%E4%B8%83%E6%A1%A5%E9%97%AE%E9%A2%98%E2%80%9D/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>哥尼斯堡是位于普累格河上的一座城市，它包含两个岛屿及连接它们的七座桥，如下图所示。</p>
<p><img src="https://images.ptausercontent.com/51" alt=""></p>
<p>可否走过这样的七座桥，而且每桥只走过一次？瑞士数学家欧拉(Leonhard Euler，1707—1783)最终解决了这个问题，并由此创立了拓扑学。</p>
<p>这个问题如今可以描述为判断欧拉回路是否存在的问题。欧拉回路是指不令笔离开纸面，可画过图中每条边仅一次，且可以回到起点的一条回路。现给定一个无向图，问是否存在欧拉回路？</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第一行给出两个正整数，分别是节点数N (1≤N≤1000)和边数M；随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个节点的编号（节点从1到N编号）。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>若欧拉回路存在则输出1，否则输出0。</p>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><h5 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1:"></a>输入样例1:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 10</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br><span class="line">6 4</span><br><span class="line">1 4</span><br><span class="line">1 6</span><br><span class="line">3 4</span><br><span class="line">3 6</span><br></pre></td></tr></table></figure>
<h5 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h5 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2:"></a>输入样例2:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 8</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">2 5</span><br><span class="line">5 3</span><br><span class="line">5 4</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure>
<h5 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h5 id="使用并查集判断连通性"><a href="#使用并查集判断连通性" class="headerlink" title="使用并查集判断连通性"></a>使用并查集判断连通性</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pre;</span><br><span class="line">    <span class="keyword">int</span> dgr = <span class="number">0</span>;</span><br><span class="line">&#125; Node[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Node[i].pre == i ? i : Node[i].pre = find(Node[i].pre);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    Node[a].dgr++;</span><br><span class="line">    Node[b].dgr++;</span><br><span class="line">    a = find(a);</span><br><span class="line">    b = find(b);</span><br><span class="line">    <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">        Node[a].pre = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Node[i].pre == i)</span><br><span class="line">            cnt++;</span><br><span class="line">        <span class="keyword">if</span> (Node[i].dgr % <span class="number">2</span>)</span><br><span class="line">            s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">1</span> &amp;&amp; s == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        Node[i].pre = i;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        link(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; judge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="dfs判断连通性"><a href="#dfs判断连通性" class="headerlink" title="dfs判断连通性"></a>dfs判断连通性</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arcs[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dgr[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> link[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">islink</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    link[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arcs[i][j] &amp;&amp; !link[j])</span><br><span class="line">            islink(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!link[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dgr[i] % <span class="number">2</span>)</span><br><span class="line">            s++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        arcs[a][b] = <span class="number">1</span>;</span><br><span class="line">        arcs[b][a] = <span class="number">1</span>;</span><br><span class="line">        dgr[a]++;</span><br><span class="line">        dgr[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    islink(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; judge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="运行时间对比"><a href="#运行时间对比" class="headerlink" title="运行时间对比"></a>运行时间对比</h5><ol>
<li>并查集<br><a href="https://ibb.co/0BhC1sx" target="_blank" rel="noopener"><img src="https://i.ibb.co/LQnxBN3/023.png" alt="023" border="0"></a></li>
<li>dfs<br><a href="https://ibb.co/G3mvgRL" target="_blank" rel="noopener"><img src="https://i.ibb.co/PzkZBgn/024.png" alt="024" border="0"></a></li>
</ol>
<p>时间限制: 400 ms<br>内存限制: 64 MB<br>代码长度限制: 16 KB</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>堆中的路径</title>
    <url>/2019/12/05/%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>将一系列给定数字插入一个初始为空的小顶堆H[]。随后对任意给定的下标i，打印从H[i]到根结点的路径。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>每组测试第1行包含2个正整数N和M(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的N个要被插入一个初始为空的小顶堆的整数。最后一行给出M个下标。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对输入中给出的每个下标i，在一行中输出从H[i]到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">46 23 26 24 10</span><br><span class="line">5 4 3</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">24 23 10</span><br><span class="line">46 23 10</span><br><span class="line">26 10</span><br></pre></td></tr></table></figure>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> h[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    s++;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = s; h[i / <span class="number">2</span>] &gt; k; i /= <span class="number">2</span>)</span><br><span class="line">        h[i] = h[i / <span class="number">2</span>];</span><br><span class="line">    h[i] = k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">int</span> N = n;</span><br><span class="line">    h[<span class="number">0</span>] = <span class="number">-10001</span>;  <span class="comment">//注意h[0]要很小，否则会进入死循环</span></span><br><span class="line">    <span class="keyword">while</span> (N--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        add(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        <span class="keyword">while</span> (t != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, h[t]);</span><br><span class="line">            t /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, h[t]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序&amp;快排&amp;堆排序</title>
    <url>/2019/12/04/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h5 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h5><p><a href="https://ibb.co/KzQQJG4" target="_blank" rel="noopener"><img src="https://i.ibb.co/sJDDZPx/1204.png" alt="1204" border="0"></a></p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;L, <span class="keyword">int</span> dk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = dk; i &lt; L.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="keyword">if</span> (L[i] &lt; L[i - dk]) &#123;</span><br><span class="line">            tmp = L[i]; <span class="comment">// 暂存</span></span><br><span class="line">            <span class="keyword">for</span> (j = i - dk; j &gt; <span class="number">0</span> &amp;&amp; L[j] &gt; tmp; j -= dk)</span><br><span class="line">                L[j + dk] = L[j]; <span class="comment">//向后移动到插入位置</span></span><br><span class="line">            L[j + dk] = tmp;      <span class="comment">//插入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;L, <span class="keyword">int</span> dlta[], <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; t; k++)</span><br><span class="line">        ShellInsert(L, dlta[k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; L = &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dlta[] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    ShellSort(L, dlta, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = L.begin();</span><br><span class="line">    <span class="keyword">for</span> (; it != L.end(); it++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, *it);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h3><h5 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h5><p>方法其实很简单：分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从右往左找一个小于 6 的数，再从左往右找一个大于 6 的数，然后交换他们。这里可以用两个变量 i 和 j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵 i”和“哨兵 j”。刚开始的时候让哨兵 i 指向序列的最左边（即 i=1），指向数字 6。让哨兵 j 指向序列的最右边（即 j=10），指向数字 8。<br><img src="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/3.1.png" alt=""></p>
<p>首先哨兵 j 开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵 j 先出动，这一点非常重要（请自己想一想为什么）。哨兵 j 一步一步地向左挪动（即 j–），直到找到一个小于 6 的数停下来。接下来哨兵 i 再一步一步向右挪动（即 i++），直到找到一个数大于 6 的数停下来。最后哨兵 j 停在了数字 5 面前，哨兵 i 停在了数字 7 面前。</p>
<p><img src="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/3.2.png" alt=""><br><img src="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/3.3.png" alt=""><br>现在交换哨兵 i 和哨兵 j 所指向的元素的值。交换之后的序列如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 1 2 5 9 3 4 7 10 8</span><br></pre></td></tr></table></figure>
<p><img src="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/3.4.png" alt=""><br><img src="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/3.5.png" alt=""></p>
<p>到此，第一次交换结束。接下来开始哨兵 j 继续向左挪动（再友情提醒，每次必须是哨兵 j 先出发）。他发现了 4（比基准数 6 要小，满足要求）之后停了下来。哨兵 i 也继续向右挪动的，他发现了 9（比基准数 6 要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 1 2 5 4 3 9 7 10 8</span><br></pre></td></tr></table></figure>
<p>第二次交换结束，“探测”继续。哨兵 j 继续向左挪动，他发现了 3（比基准数 6 要小，满足要求）之后又停了下来。哨兵 i 继续向右移动，糟啦！此时哨兵 i 和哨兵 j 相遇了，哨兵 i 和哨兵 j 都走到 3 面前。说明此时“探测”结束。我们将基准数 6 和 3 进行交换。交换之后的序列如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 1 2 5 4 6 9 7 10 8</span><br></pre></td></tr></table></figure>
<p><img src="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/3.6.png" alt=""></p>
<p><img src="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/3.7.png" alt=""><br><img src="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/3.8.png" alt=""></p>
<p>到此第一轮“探测”真正结束。此时以基准数 6 为分界点，6 左边的数都小于等于 6，6 右边的数都大于等于 6。回顾一下刚才的过程，其实哨兵 j 的使命就是要找小于基准数的数，而哨兵 i 的使命就是要找大于基准数的数，直到 i 和 j 碰头为止。</p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> L[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    L[<span class="number">0</span>] = L[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; L[high] &gt;= L[<span class="number">0</span>])</span><br><span class="line">            --high;</span><br><span class="line">        L[low] = L[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; L[low] &lt;= L[<span class="number">0</span>])</span><br><span class="line">            ++low;</span><br><span class="line">        L[high] = L[low];</span><br><span class="line">    &#125;</span><br><span class="line">    L[low] = L[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(<span class="keyword">int</span> L[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = Partition(L, low, high);</span><br><span class="line">        QSort(L, low, p - <span class="number">1</span>);</span><br><span class="line">        QSort(L, p + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l[] = &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    QSort(l, <span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, l[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h5 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h5><p><img src="https://pic3.zhimg.com/v2-96d015c3735bf3b996043e29d4a0fc96_b.webp" alt=""></p>
<h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span> heap[], <span class="keyword">int</span> s, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = heap[s]; <span class="comment">//使heap[s..m]成为一个大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * s; j &lt;= m; j *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; m &amp;&amp; (heap[j] &lt; heap[j + <span class="number">1</span>]))</span><br><span class="line">            ++j; <span class="comment">// j为较大位置</span></span><br><span class="line">        <span class="keyword">if</span> (rc &gt;= heap[j])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        heap[s] = heap[j];</span><br><span class="line">        s = j;</span><br><span class="line">    &#125;</span><br><span class="line">    heap[s] = rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> heap[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        heapAdjust(heap, i, n); <span class="comment">//把heap[1..n]构建为大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        swap(heap[<span class="number">1</span>], heap[i]);</span><br><span class="line">        heapAdjust(heap, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h[] = &#123;<span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    heapSort(h, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, h[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>让课代表收作业变得更简单</title>
    <url>/2019/12/02/%E9%82%AE%E4%BB%B6%E9%99%84%E4%BB%B6%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ol>
<li>一个邮箱地址和密码</li>
<li>Python3环境</li>
</ol>
<h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><ol>
<li>在邮箱设置里开启pop</li>
<li>安装xlwt和xlrd<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install xlwt</span><br><span class="line">pip3 install xlrd</span><br></pre></td></tr></table></figure></li>
<li>将下面代码中的邮件地址, 口令和POP3服务器地址改为你所对应的；并指定att_file(存储路径)。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> poplib</span><br><span class="line"><span class="keyword">import</span> email</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="keyword">from</span> email.parser <span class="keyword">import</span> Parser</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> decode_header</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> parseaddr</span><br><span class="line"><span class="comment"># 输入邮件地址, 口令和POP3服务器地址:</span></span><br><span class="line">email = <span class="string">'***@163.com'</span></span><br><span class="line">password = <span class="string">'********'</span></span><br><span class="line">pop3_server = <span class="string">'pop.163.com'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode_str</span><span class="params">(s)</span>:</span> <span class="comment">#字符编码转换</span></span><br><span class="line">    value, charset = decode_header(s)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> charset:</span><br><span class="line">        value = value.decode(charset)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_att</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> email</span><br><span class="line">    attachment_files = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> part <span class="keyword">in</span> msg.walk():</span><br><span class="line">        file_name = part.get_filename()<span class="comment">#获取附件名称类型</span></span><br><span class="line">        contType = part.get_content_type()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> file_name:</span><br><span class="line">            h = email.header.Header(file_name)</span><br><span class="line">            dh = email.header.decode_header(h)<span class="comment">#对附件名称进行解码</span></span><br><span class="line">            filename = dh[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> dh[<span class="number">0</span>][<span class="number">1</span>]:</span><br><span class="line">                filename = decode_str(str(filename,dh[<span class="number">0</span>][<span class="number">1</span>]))<span class="comment">#将附件名称可读化</span></span><br><span class="line">                print(filename)</span><br><span class="line">                <span class="comment">#filename = filename.encode("utf-8")</span></span><br><span class="line">            data = part.get_payload(decode=<span class="literal">True</span>)<span class="comment">#下载附件</span></span><br><span class="line">            att_file = open(<span class="string">'/home/mail/test/'</span> + filename, <span class="string">'wb'</span>)<span class="comment">#在指定目录下创建文件，注意二进制文件需要用wb模式打开</span></span><br><span class="line">            attachment_files.append(filename)</span><br><span class="line">            att_file.write(data)<span class="comment">#保存附件</span></span><br><span class="line">            att_file.close()</span><br><span class="line">    <span class="keyword">return</span> attachment_files</span><br><span class="line"><span class="comment"># 连接到POP3服务器,有些邮箱服务器需要ssl加密，对于不需要加密的服务器可以使用poplib.POP3()</span></span><br><span class="line">server = poplib.POP3_SSL(pop3_server)</span><br><span class="line">server.set_debuglevel(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 打印POP3服务器的欢迎文字:</span></span><br><span class="line">print(server.getwelcome().decode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="comment"># 身份认证:</span></span><br><span class="line">server.user(email)</span><br><span class="line">server.pass_(password)</span><br><span class="line"><span class="comment"># 返回邮件数量和占用空间:</span></span><br><span class="line">print(<span class="string">'Messages: %s. Size: %s'</span> % server.stat())</span><br><span class="line"><span class="comment"># list()返回所有邮件的编号:</span></span><br><span class="line">resp, mails, octets = server.list()</span><br><span class="line"><span class="comment"># 可以查看返回的列表类似[b'1 82923', b'2 2184', ...]</span></span><br><span class="line">print(mails)</span><br><span class="line">index = len(mails)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(index,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">    <span class="comment">#倒序遍历邮件</span></span><br><span class="line">    resp, lines, octets = server.retr(i)</span><br><span class="line">    <span class="comment"># lines存储了邮件的原始文本的每一行,</span></span><br><span class="line">    <span class="comment">#邮件的原始文本:</span></span><br><span class="line">    msg_content = <span class="string">b'\r\n'</span>.join(lines).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="comment">#解析邮件:</span></span><br><span class="line">    msg = Parser().parsestr(msg_content)</span><br><span class="line">    <span class="comment">#获取邮件时间</span></span><br><span class="line">    date1 = time.strptime(msg.get(<span class="string">"Date"</span>)[<span class="number">0</span>:<span class="number">24</span>],<span class="string">'%a, %d %b %Y %H:%M:%S'</span>) <span class="comment">#格式化收件时间</span></span><br><span class="line">    date2 = time.strftime(<span class="string">"%Y%m%d"</span>, date1)<span class="comment">#邮件时间格式转换</span></span><br><span class="line">    <span class="keyword">if</span> (date2&lt;<span class="string">'20180306'</span>)|(date2&gt;<span class="string">'20200314'</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    f_list = get_att(msg)<span class="comment">#获取附件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#print_info(msg)</span></span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure></li>
<li>运行此脚本。</li>
</ol>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表设计</title>
    <url>/2019/12/01/%E5%93%88%E5%B8%8C%E8%A1%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>针对某个集体（比如你所在的班级）中的“人名”设计一个哈希表，使得平均查找长度不超过R，完成相应的建表和查表程序。</p>
<h3 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h3><p>假设人名为中国人姓名的汉语拼音形式。待填入哈希表的人名共有30个，取平均查找长度的上限为2。哈希函数用除留余数法构造，用伪随机探测再散列发处理冲突。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 50</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; Name[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">&#125; HashList[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(<span class="string">"text.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">        fgets(Name[i].str, <span class="number">20</span>, fp);</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; Name[i].str[j] != <span class="string">'\n'</span>; j++)</span><br><span class="line">            ;</span><br><span class="line">        Name[i].str[j] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; Name[i].str[j] != <span class="string">'\0'</span>; j++) &#123;</span><br><span class="line">            s += Name[i].str[j];</span><br><span class="line">        &#125;</span><br><span class="line">        Name[i].value = s;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s %d\n"</span>, Name[i].str, Name[i].value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHashList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">        HashList[i].key = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(HashList[i].name, <span class="string">""</span>);</span><br><span class="line">        HashList[i].sum = <span class="number">0</span>;</span><br><span class="line">        HashList[i].flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> adr = Name[i].value % <span class="number">47</span>;</span><br><span class="line">        <span class="keyword">int</span> next_adr = adr;</span><br><span class="line">        <span class="keyword">if</span> (HashList[adr].flag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"adr: %d\n"</span>, adr);</span><br><span class="line">            HashList[adr].key = Name[i].value;</span><br><span class="line">            <span class="built_in">strcpy</span>(HashList[adr].name, Name[i].str);</span><br><span class="line">            HashList[adr].flag = <span class="number">1</span>;</span><br><span class="line">            HashList[adr].sum = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                count++;</span><br><span class="line">                next_adr = (next_adr + (Name[i].value % <span class="number">10</span>) + <span class="number">1</span>) % <span class="number">47</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (HashList[next_adr].flag);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"adr: %d\n"</span>, next_adr);</span><br><span class="line">            HashList[next_adr].key = Name[i].value;</span><br><span class="line">            <span class="built_in">strcpy</span>(HashList[next_adr].name, Name[i].str);</span><br><span class="line">            HashList[next_adr].flag = <span class="number">1</span>;</span><br><span class="line">            HashList[next_adr].sum = count + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"请输入要查找人的姓名"</span>);</span><br><span class="line">    <span class="built_in">cin</span>.getline(name, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)<span class="built_in">strlen</span>(name); i++)</span><br><span class="line">        value += name[i];</span><br><span class="line">    <span class="keyword">int</span> adr = value % <span class="number">47</span>;</span><br><span class="line">    <span class="keyword">int</span> next_adr = adr;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(HashList[adr].name, name) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"姓名：%s 关键字：%d 查找长度：%d"</span>, HashList[adr].name,</span><br><span class="line">               HashList[adr].key, HashList[adr].sum);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HashList[adr].sum == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"没有该人\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            next_adr = (next_adr + ((value % <span class="number">10</span>) + <span class="number">1</span>)) % <span class="number">47</span>;</span><br><span class="line">            <span class="keyword">if</span> ((HashList[next_adr].flag == <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">strcmp</span>(HashList[next_adr].name, name) != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (HashList[next_adr].flag)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"姓名：%s 关键字：%d 查找长度：%d"</span>, HashList[next_adr].name,</span><br><span class="line">                   HashList[next_adr].key, HashList[next_adr].sum);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"没有该人\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> ave;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"地址\t关键字\t查找长度\t姓名"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\t%d\t%d\t%s\n"</span>, i, HashList[i].key, HashList[i].sum,</span><br><span class="line">               HashList[i].name);</span><br><span class="line">        ave += HashList[i].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    ave /= <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"平均查找长度为%.3f\n"</span>, ave);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    createHashList();</span><br><span class="line">    show();</span><br><span class="line">    searchHash();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉排序树的合并</title>
    <url>/2019/12/01/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>试编写程序，将两棵二叉排序树合并为一棵二叉排序树。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>按照先序序列，分两行输入两棵二叉排序树各结点（结点值大于0），其中-1表示取消建立子树结点。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>按照中序序列输出合并后的二叉排序树。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12 8 4 -1 -1 10 -1 -1 16 13 -1 -1 18 -1 -1</span><br><span class="line">17 6 2 -1 -1 9 -1 -1 24 19 -1 -1 26 -1 -1</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 4 6 8 9 10 12 13 16 17 18 19 24 26</span><br></pre></td></tr></table></figure>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> n) : data(n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createBTree</span><span class="params">(TreeNode *&amp;root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="number">-1</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TreeNode(t);</span><br><span class="line">        createBTree(root-&gt;left);</span><br><span class="line">        createBTree(root-&gt;right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        inOrder(root-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, root-&gt;data);</span><br><span class="line">        inOrder(root-&gt;right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(TreeNode *&amp;root, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TreeNode(d);</span><br><span class="line">        root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;data == d)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((root-&gt;data) &gt; d) &#123;</span><br><span class="line">            insert((root-&gt;left), d);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            insert((root-&gt;right), d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeTree</span><span class="params">(TreeNode *&amp;a, TreeNode *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b) &#123;</span><br><span class="line">        mergeTree(a, b-&gt;left);</span><br><span class="line">        insert(a, b-&gt;data);</span><br><span class="line">        mergeTree(a, b-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int start = clock();</span></span><br><span class="line">    TreeNode *a;</span><br><span class="line">    TreeNode *b;</span><br><span class="line">    createBTree(a);</span><br><span class="line">    createBTree(b);</span><br><span class="line">    mergeTree(a, b);</span><br><span class="line">    inOrder(a);</span><br><span class="line">    <span class="keyword">int</span> end = clock();</span><br><span class="line">    <span class="comment">// printf("\n%d\n", end - start);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>二叉排序树</tag>
      </tags>
  </entry>
  <entry>
    <title>六度空间</title>
    <url>/2019/11/29/%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图1所示。</p>
<p><img src="https://images.ptausercontent.com/35" alt="图1 六度空间示意图"></p>
<p>“六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。</p>
<p><strong>假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。</strong></p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出两个正整数，分别表示社交网络图的结点数N（1&lt;N≤1000​ ，表示人数）、边数M≤33×N，表示社交关系数）。随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到N编号）。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 9</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br><span class="line">6 7</span><br><span class="line">7 8</span><br><span class="line">8 9</span><br><span class="line">9 10</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: 70.00%</span><br><span class="line">2: 80.00%</span><br><span class="line">3: 90.00%</span><br><span class="line">4: 100.00%</span><br><span class="line">5: 100.00%</span><br><span class="line">6: 100.00%</span><br><span class="line">7: 100.00%</span><br><span class="line">8: 90.00%</span><br><span class="line">9: 80.00%</span><br><span class="line">10: 70.00%</span><br></pre></td></tr></table></figure>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> arcs[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            arcs[i][j] = <span class="number">2005</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        arcs[a][b] = <span class="number">1</span>;</span><br><span class="line">        arcs[b][a] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            d[i][j] = arcs[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        d[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">                d[j][k] = min(d[j][i] + d[i][k], d[j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[i][j] &lt;= <span class="number">6</span>)</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: %.2f%\n"</span>, i, <span class="number">100.0</span> * count / n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read();</span><br><span class="line">    solve();</span><br><span class="line">    print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/15/problems/715" target="_blank" rel="noopener">题目链接</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>列出可连通集</title>
    <url>/2019/11/28/%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个有N个顶点和E条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到N−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出2个整数N(0&lt;N≤10)和E，分别是图的顶点数和边数。随后E行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>按照如下的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 6</span><br><span class="line">0 7</span><br><span class="line">0 1</span><br><span class="line">2 0</span><br><span class="line">4 1</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; 0 1 4 2 7 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h5 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N, E;</span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">bool</span> arcs[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; E;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span> (E--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        arcs[a][b] = <span class="number">1</span>;</span><br><span class="line">        arcs[b][a] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" %d"</span>, v);</span><br><span class="line">    visit[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visit[i] &amp;&amp; arcs[v][i]) &#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_t</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visit[i]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"&#123;"</span>);</span><br><span class="line">            dfs(i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" &#125;\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="keyword">if</span> (!visit[i]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"&#123;"</span>);</span><br><span class="line">            Q.push(i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>, i);</span><br><span class="line">            visit[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = Q.front();</span><br><span class="line">                Q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!visit[j] &amp;&amp; arcs[t][j]) &#123;</span><br><span class="line">                        visit[j] = <span class="number">1</span>;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">" %d"</span>, j);</span><br><span class="line">                        Q.push(j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" &#125;\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read();</span><br><span class="line">    <span class="keyword">dfs_t</span>();</span><br><span class="line">    bfs();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> f[i] == i ? i : f[i] = find(f[i]); &#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    a = find(a);</span><br><span class="line">    b = find(b);</span><br><span class="line">    <span class="keyword">if</span> (a != b)</span><br><span class="line">        f[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        f[i] = i;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        link(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visit[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"&#123; %d"</span>, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visit[j] &amp;&amp; f[i] == f[j]) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %d"</span>, j);</span><br><span class="line">                visit[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!visit[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" &#125;\n"</span>);</span><br><span class="line">        visit[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read();</span><br><span class="line">    print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>最大子列和问题</title>
    <url>/2019/11/28/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定K个整数组成的序列,其中“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。</p>
<p>本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据1：与样例等价，测试基本正确性；</span><br><span class="line">数据2：102个随机整数；</span><br><span class="line">数据3：103个随机整数；</span><br><span class="line">数据4：104个随机整数；</span><br><span class="line">数据5：105个随机整数；</span><br></pre></td></tr></table></figure>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出正整数K (≤100000)；第2行给出K个整数，其间以空格分隔。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">-2 11 -4 13 -5 -2</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure>

<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>最大连续子列只可能是以0～n-1位置结尾，若前面位置的最大连续子列和max(i-1) &gt; 0, 则以i位置结尾的最大连续子列和max(i)为max(i-1) + nums[i], 否则为nums[i]。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cur = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cur = (cur &gt; <span class="number">0</span> ? cur + a[i] : a[i]);</span><br><span class="line">        <span class="keyword">if</span> (cur &gt; max)</span><br><span class="line">            max = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; getMax() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/15/problems/709" target="_blank" rel="noopener">题目链接</a></p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>一元多项式的乘法和加法运算</title>
    <url>/2019/11/28/%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B9%98%E6%B3%95%E5%92%8C%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><strong>设计函数分别求两个一元多项式的乘积与和。</strong></p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出0 0。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3 4 -5 2  6 1  -2 0</span><br><span class="line">3 5 20  -7 4  3 1</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1</span><br><span class="line">5 20 -4 4 -5 2 9 1 -2 0</span><br></pre></td></tr></table></figure>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> A[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> B[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> C[<span class="number">2005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1, t2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t1 &gt;&gt; t2;</span><br><span class="line">        A[t2] += t1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t1 &gt;&gt; t2;</span><br><span class="line">        B[t2] += t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> zero = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1004</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1004</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            C[i + j] += A[i] * B[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2004</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (C[i]) &#123;</span><br><span class="line">            zero = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(flag ? <span class="string">"%d %d"</span> : <span class="string">" %d %d"</span>, C[i], i);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (zero)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0 0"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> zero = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1004</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = A[i] + B[i];</span><br><span class="line">        <span class="keyword">if</span> (t) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(flag ? <span class="string">"%d %d"</span> : <span class="string">" %d %d"</span>, t, i);</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            zero = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (zero)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0 0"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read();</span><br><span class="line">    mul();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    add();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/15/problems/710" target="_blank" rel="noopener">题目链接</a></p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历</title>
    <url>/2019/11/26/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><strong>二叉树的遍历</strong><br>本题要求给定二叉树的4种遍历。</p>
<p>函数接口定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTraversal</span><span class="params">( BinTree BT )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTraversal</span><span class="params">( BinTree BT )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostorderTraversal</span><span class="params">( BinTree BT )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelorderTraversal</span><span class="params">( BinTree BT )</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中BinTree结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position BinTree;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>要求4个函数分别按照访问顺序打印出结点的内容，格式为一个空格跟着一个字符。</p>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><p>（对于图中给出的树）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Inorder: D B E F A G H C I</span><br><span class="line">Preorder: A B D F E C G H I</span><br><span class="line">Postorder: D E F B H G I C A</span><br><span class="line">Levelorder: A B C D F G I E H</span><br></pre></td></tr></table></figure>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTraversal</span><span class="params">(BinTree BT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (BT) &#123;</span><br><span class="line">        InorderTraversal(BT-&gt;Left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %c"</span>, BT-&gt;Data);</span><br><span class="line">        InorderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTraversal</span><span class="params">(BinTree BT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (BT) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %c"</span>, BT-&gt;Data);</span><br><span class="line">        PreorderTraversal(BT-&gt;Left);</span><br><span class="line">        PreorderTraversal(BT-&gt;Right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostorderTraversal</span><span class="params">(BinTree BT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (BT) &#123;</span><br><span class="line">        PostorderTraversal(BT-&gt;Left);</span><br><span class="line">        PostorderTraversal(BT-&gt;Right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %c"</span>, BT-&gt;Data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelorderTraversal</span><span class="params">(BinTree BT)</span> </span>&#123;</span><br><span class="line">    BinTree Q[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (BT) &#123;</span><br><span class="line">        Q[++rear] = BT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (front != rear) &#123;</span><br><span class="line">        BinTree tmp = Q[++front];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %c"</span>, tmp-&gt;Data);</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;Left)</span><br><span class="line">            Q[++rear] = tmp-&gt;Left;</span><br><span class="line">        <span class="keyword">if</span> (tmp-&gt;Right)</span><br><span class="line">            Q[++rear] = tmp-&gt;Right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/15/problems/732" target="_blank" rel="noopener">题目链接</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树前序、中序、后序遍历的相互求法</title>
    <url>/2019/11/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84%E8%BD%AC%E5%8C%96/</url>
    <content><![CDATA[<h3 id="一、已知前序、中序、求后序遍历"><a href="#一、已知前序、中序、求后序遍历" class="headerlink" title="一、已知前序、中序、求后序遍历"></a>一、已知前序、中序、求后序遍历</h3><p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前序遍历: GDAFEMHZ</span><br><span class="line">中序遍历: ADEFGHMZ</span><br></pre></td></tr></table></figure>
<ol>
<li><p>根据前序遍历的特点，我们知道根结点为G</p>
</li>
<li><p>观察中序遍历ADEFGHMZ。其中root节点G左侧的ADEF必然是root的左子树，G右侧的HMZ必然是root的右子树。</p>
</li>
<li><p>观察左子树ADEF，左子树的中的根节点必然是大树的root的leftchild。在前序遍历中，大树的root的leftchild位于root之后，所以左子树的根节点为D。</p>
</li>
<li><p>同样的道理，root的右子树节点HMZ中的根节点也可以通过前序遍历求得。在前序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。</p>
</li>
<li><p>观察发现，上面的过程是递归的。先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。该步递归的过程可以简洁表达如下：</p>
<ol>
<li>确定根,确定左子树，确定右子树。</li>
<li>在左子树中递归。</li>
<li>在右子树中递归。</li>
<li>打印当前根。</li>
</ol>
</li>
</ol>
<p>核心代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">buildTreebyPre(preorder + <span class="number">1</span>, inorder, root_idx, root-&gt;left);</span><br><span class="line">buildTreebyPre(preorder + <span class="number">1</span> + root_idx, inorder + root_idx + <span class="number">1</span>, length - (root_idx + <span class="number">1</span>), root-&gt;right);</span><br></pre></td></tr></table></figure>
<h3 id="二、已知中序、后序遍历、求前序遍历"><a href="#二、已知中序、后序遍历、求前序遍历" class="headerlink" title="二、已知中序、后序遍历、求前序遍历"></a>二、已知中序、后序遍历、求前序遍历</h3><p>依然是上面的题，这次我们只给出中序和后序遍历：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">中序遍历: ADEFGHMZ</span><br><span class="line">后序遍历: AEFDHZMG</span><br></pre></td></tr></table></figure>
<ol>
<li><p>根据后序遍历的特点，我们知道后序遍历最后一个结点即为根结点，即根结点为G。</p>
</li>
<li><p>观察中序遍历ADEFGHMZ。其中root节点G左侧的ADEF必然是root的左子树，G右侧的HMZ必然是root的右子树。</p>
</li>
<li><p>观察左子树ADEF，左子树的中的根节点必然是大树的root的leftchild。在前序遍历中，大树的root的leftchild位于root之后，所以左子树的根节点为D。</p>
</li>
<li><p>同样的道理，root的右子树节点HMZ中的根节点也可以通过前序遍历求得。在前后序遍历中，一定是先把root和root的所有左子树节点遍历完之后才会遍历右子树，并且遍历的左子树的第一个节点就是左子树的根节点。同理，遍历的右子树的第一个节点就是右子树的根节点。</p>
</li>
<li><p>观察发现，上面的过程是递归的。先找到当前树的根节点，然后划分为左子树，右子树，然后进入左子树重复上面的过程，然后进入右子树重复上面的过程。最后就可以还原一棵树了。该步递归的过程可以简洁表达如下：</p>
<ol>
<li>确定根,确定左子树，确定右子树。</li>
<li>在左子树中递归。</li>
<li>在右子树中递归。</li>
<li>打印当前根。</li>
</ol>
</li>
</ol>
<p>核心代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">buildTreebyAft(aftorder, inorder, root_idx, root-&gt;left);</span><br><span class="line">buildTreebyAft(aftorder + root_idx, inorder + root_idx + <span class="number">1</span>, length - root_idx - <span class="number">1</span>, root-&gt;right);</span><br></pre></td></tr></table></figure>

<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">char</span> e) : data(e) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTree</span><span class="params">(TreeNode *&amp;root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="string">' '</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TreeNode(c);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输入%c的左子树\n"</span>, c);</span><br><span class="line">        createTree(root-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输入%c的右子树\n"</span>, c);</span><br><span class="line">        createTree(root-&gt;right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aftOrder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        aftOrder(root-&gt;left);</span><br><span class="line">        aftOrder(root-&gt;right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, root-&gt;data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, root-&gt;data);</span><br><span class="line">        preOrder(root-&gt;left);</span><br><span class="line">        preOrder(root-&gt;right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTreebyPre</span><span class="params">(<span class="keyword">char</span> *preorder, <span class="keyword">char</span> *inorder, <span class="keyword">int</span> length,</span></span></span><br><span class="line"><span class="function"><span class="params">                    TreeNode *&amp;root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">        root = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> root_data = preorder[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> root_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; inorder[root_idx] != root_data; root_idx++)</span><br><span class="line">        ;</span><br><span class="line">    root = <span class="keyword">new</span> TreeNode(root_data);</span><br><span class="line">    buildTreebyPre(preorder + <span class="number">1</span>, inorder, root_idx, root-&gt;left);</span><br><span class="line">    buildTreebyPre(preorder + <span class="number">1</span> + root_idx, inorder + root_idx + <span class="number">1</span>,</span><br><span class="line">                   length - (root_idx + <span class="number">1</span>), root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTreebyAft</span><span class="params">(<span class="keyword">char</span> *aftorder, <span class="keyword">char</span> *inorder, <span class="keyword">int</span> length,</span></span></span><br><span class="line"><span class="function"><span class="params">                    TreeNode *&amp;root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">        root = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> root_data = aftorder[length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> root_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; inorder[root_idx] != root_data; root_idx++)</span><br><span class="line">        ;</span><br><span class="line">    root = <span class="keyword">new</span> TreeNode(root_data);</span><br><span class="line">    buildTreebyAft(aftorder, inorder, root_idx, root-&gt;left);</span><br><span class="line">    buildTreebyAft(aftorder + root_idx, inorder + root_idx + <span class="number">1</span>,</span><br><span class="line">                   length - root_idx - <span class="number">1</span>, root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TreeNode *root = <span class="literal">NULL</span>;</span><br><span class="line">    buildTreebyPre(<span class="string">"GDAFEMHZ"</span>, <span class="string">"ADEFGHMZ"</span>, <span class="number">8</span>, root);</span><br><span class="line">    aftOrder(root);</span><br><span class="line">    root = <span class="literal">NULL</span>;</span><br><span class="line">    buildTreebyAft(<span class="string">"AEFDHZMG"</span>, <span class="string">"ADEFGHMZ"</span>, <span class="number">8</span>, root);</span><br><span class="line">    preOrder(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原文链接：<a href="https://blog.csdn.net/u014536527/article/details/51010702" target="_blank" rel="noopener">https://blog.csdn.net/u014536527/article/details/51010702</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-50 &amp; LeetCode-34</title>
    <url>/2019/11/23/LeetCode-50/</url>
    <content><![CDATA[<h3 id="LeetCode-50-Pow-x-n"><a href="#LeetCode-50-Pow-x-n" class="headerlink" title="LeetCode-50-Pow(x, n)"></a>LeetCode-50-Pow(x, n)</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p><strong>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</strong></p>
<ul>
<li>示例 1:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure></li>
<li>示例 2:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br></pre></td></tr></table></figure></li>
<li>示例 3:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br></pre></td></tr></table></figure></li>
<li>解释: 2-2 = 1/22 = 1/4 = 0.25</li>
<li>说明:</li>
</ul>
<p>-100.0 &lt; x &lt; 100.0, n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">quickPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">double</span> half = quickPow(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> half * half;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> half * half * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            N = -N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> quickPow(x, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LeetCode-34-在排序数组中查找元素的第一个和最后一个位置"><a href="#LeetCode-34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="LeetCode-34-在排序数组中查找元素的第一个和最后一个位置"></a>LeetCode-34-在排序数组中查找元素的第一个和最后一个位置</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p><strong>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</strong></p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>如果数组中不存在目标值，返回 [-1, -1]。</p>
<ul>
<li>示例 1:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: [3,4]</span><br></pre></td></tr></table></figure></li>
<li>示例 2:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: [-1,-1]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search_left</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 寻找左边界</span></span><br><span class="line">        <span class="keyword">if</span> (!nums.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size();</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == nums.size()) <span class="comment">// target比所有数大</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> nums[left] == target ? left : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search_right</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//寻找右边界</span></span><br><span class="line">        <span class="keyword">if</span> (!nums.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size();</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">0</span>) <span class="comment">// target比所有数小</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> nums[right - <span class="number">1</span>] == target ? right - <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        ans.push_back(search_left(nums, target));</span><br><span class="line">        ans.push_back(search_right(nums, target));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>二分查找</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找及二叉排序树</title>
    <url>/2019/11/22/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%8A%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ol>
<li>顺序表的二分查找（折半查找),同时实现寻找左边界和右边界的算法</li>
<li>二叉排序树的查找、删除以及添加结点</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h6 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_bi</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_left</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 寻找左边界</span></span><br><span class="line">    <span class="keyword">if</span> (!nums.size())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.size();</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left == nums.size()) <span class="comment">// target比所有数大</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> nums[left] == target ? left : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_right</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//寻找右边界</span></span><br><span class="line">    <span class="keyword">if</span> (!nums.size())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.size();</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="number">0</span>) <span class="comment">// target比所有数小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> nums[right - <span class="number">1</span>] == target ? right - <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">int</span> n, t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        v.push_back(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; search_bi(v, <span class="number">4</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; search_left(v, <span class="number">3</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; search_right(v, <span class="number">5</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node *left;</span><br><span class="line">    Node *right;</span><br><span class="line">&#125; * BiTree;</span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"datain.txt"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c; <span class="comment">//输入-1表示NULL</span></span><br><span class="line">    in &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">-1</span>) &#123;</span><br><span class="line">        T = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        T-&gt;data = c;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入%d的左孩子\n"</span>, c);</span><br><span class="line">        CreateBiTree(T-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入%d的右孩子\n"</span>, c);</span><br><span class="line">        CreateBiTree(T-&gt;right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        Traverse(T-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T-&gt;data);</span><br><span class="line">        Traverse(T-&gt;right);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BiTree <span class="title">SearchBST</span><span class="params">(BiTree T, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T || key == T-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;data &gt; key)</span><br><span class="line">        SearchBST(T-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        SearchBST(T-&gt;right, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SearchBST</span><span class="params">(BiTree T, <span class="keyword">int</span> key, BiTree f, BiTree &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查找成功，f指向T的双亲</span></span><br><span class="line">    <span class="keyword">if</span> (!T) &#123;</span><br><span class="line">        p = f;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;data == key) &#123;</span><br><span class="line">        p = T;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;data &gt; key)</span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;left, key, T, p);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;right, key, T, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertBST</span><span class="params">(BiTree &amp;T, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查找不成功，在适当位置插入</span></span><br><span class="line">    Node *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!SearchBST(T, e, <span class="literal">NULL</span>, p)) &#123;</span><br><span class="line">        Node *node = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        node-&gt;data = e;</span><br><span class="line">        node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p)</span><br><span class="line">            p = node;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;data &gt; e)</span><br><span class="line">            p-&gt;left = node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p-&gt;right = node;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Delete</span><span class="params">(BiTree &amp;p)</span> </span>&#123;</span><br><span class="line">    Node *q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;left) &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;right) &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;left;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q = p;</span><br><span class="line">        Node *s = p-&gt;left;</span><br><span class="line">        <span class="keyword">while</span> (s-&gt;right) &#123;</span><br><span class="line">            q = s;</span><br><span class="line">            s = s-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data = s-&gt;data;</span><br><span class="line">        <span class="keyword">if</span> (q != p)</span><br><span class="line">            q-&gt;right = s-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            q-&gt;left = s-&gt;left;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteBST</span><span class="params">(BiTree &amp;T, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若存在key则删除</span></span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;data == key)</span><br><span class="line">            <span class="keyword">return</span> Delete(T);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (T-&gt;data &gt; key)</span><br><span class="line">            <span class="keyword">return</span> DeleteBST(T-&gt;left, key);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> DeleteBST(T-&gt;right, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BiTree T;</span><br><span class="line">    CreateBiTree(T);</span><br><span class="line">    Traverse(T);</span><br><span class="line">    Node *node = SearchBST(T, <span class="number">37</span>);</span><br><span class="line">    <span class="keyword">if</span> (node)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; node-&gt;data &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//验证是否正确找到</span></span><br><span class="line">    InsertBST(T, <span class="number">38</span>);</span><br><span class="line">    Traverse(T);</span><br><span class="line">    DeleteBST(T, <span class="number">38</span>);</span><br><span class="line">    Traverse(T);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ-2387-Til_the_Cows_Come_Home</title>
    <url>/2019/11/22/Poj2387/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>贝西（Bessie）在野外，想回到谷仓以尽可能多地睡觉，直到农夫约翰（John Farmer）叫醒她早上进行挤奶。贝西需要美睡，所以她想尽快回来。</p>
<p>农夫约翰的田地里有N（2 &lt;= N &lt;= 1000）个地标，唯一编号为1..N。地标1是谷仓；Bessie整日站立的苹果树丛是地标N。奶牛使用地标之间长度各异的T（1 &lt;= T &lt;= 2000）双向奶牛场在田间旅行。贝西对自己的导航能力不抱有信心，因此，从开始到结束，她始终保持在步道上。</p>
<p>给定地标之间的路径，确定Bessie返回谷仓必须行走的最小距离。可以保证存在这样的路经。</p>
<h6 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h6><p>题目会给你n个点，m条边，然后给你每条边又哪两个点相连，并且其中的路程是多少。我们需要找到最短路径的总路程。</p>
<h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 2 20</span><br><span class="line">2 3 30</span><br><span class="line">3 4 20</span><br><span class="line">4 5 20</span><br><span class="line">1 5 100</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">90</span><br></pre></td></tr></table></figure>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max 0xfffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1005</span></span><br><span class="line"><span class="keyword">int</span> arcs[N][N];</span><br><span class="line"><span class="keyword">int</span> visit[N];</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="keyword">int</span> n, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shortestPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j, k, min;</span><br><span class="line">  <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    f[i] = arcs[<span class="number">1</span>][i];</span><br><span class="line">  f[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    min = Max;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!visit[j] &amp;&amp; f[j] &lt; min) &#123;</span><br><span class="line">        min = f[j];</span><br><span class="line">        k = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (min == Max)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    visit[k] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!visit[j] &amp;&amp; f[j] &gt; f[k] + arcs[k][j]) &#123;</span><br><span class="line">        f[j] = f[k] + arcs[k][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; f[n] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;t, &amp;n) != EOF) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        arcs[i][j] = Max;</span><br><span class="line">      arcs[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; t; j++) &#123;</span><br><span class="line">      <span class="keyword">int</span> a, b, len;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;len);</span><br><span class="line">      <span class="keyword">if</span> (arcs[a][b] &gt; len)</span><br><span class="line">        arcs[a][b] = arcs[b][a] = len;</span><br><span class="line">    &#125;</span><br><span class="line">    shortestPath();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树的求法</title>
    <url>/2019/11/21/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>请对下图的无向带权图<br>(1)写出它的邻接矩阵，并按普里姆算法求其最小生成树；<br>(2)写出它的邻接表，并按克鲁斯卡尔算法求其最小生成树。<br><img src="https://uploadfiles.nowcoder.com/images/20180315/5994168_1521087479012_6CE28496EAA7968C3C38F82FBC2CD075" alt=""></p>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><h6 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 4 3 - - - - -</span><br><span class="line">4 0 5 5 9 - - -</span><br><span class="line">3 5 0 5 - - - 5</span><br><span class="line">- 5 5 0 7 6 5 4</span><br><span class="line">- 9 - 7 0 3 - -</span><br><span class="line">- - - 6 3 0 2 -</span><br><span class="line"> - - - 5 - 2 0 6</span><br><span class="line"> - - 5 4 - - 6 0</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM 31</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> VertexType;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">graph</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line">	<span class="keyword">int</span> vexnum;</span><br><span class="line">	<span class="keyword">int</span> arcnum;</span><br><span class="line">&#125; * Graph;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	VertexType adjvex;</span><br><span class="line">	<span class="keyword">int</span> lowcost;</span><br><span class="line">&#125; closedge[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">(Graph &amp;G)</span> </span>&#123;</span><br><span class="line">	G = (Graph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(graph));</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"请输入图的结点数"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;G-&gt;vexnum);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"请输入邻接矩阵"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= G-&gt;vexnum; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= G-&gt;vexnum; j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;G-&gt;arcs[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 0 4 3 INF INF INF INF INF 4 0 5 5 9 INF INF INF 3 5 0 5 INF INF INF 5 INF 5 5 0 7 6 5 4 INF 9 INF 7 0 3 INF INF INF INF INF 6 3 0 2 INF INF INF INF 5 INF 2 0 6 INF INF 5 4 INF INF 6 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MiniSpanTree</span><span class="params">(Graph G, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = c-<span class="string">'a'</span>+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">bool</span> visit[MAX_VERTEX_NUM];</span><br><span class="line">	<span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="keyword">sizeof</span>(visit));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= G-&gt;vexnum; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i != k)</span><br><span class="line">			closedge[i] = &#123;k, G-&gt;arcs[k][i]&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	closedge[k].lowcost = <span class="number">0</span>;</span><br><span class="line">	visit[k] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= G-&gt;vexnum; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">min</span> = INF;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= G-&gt;vexnum; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!visit[j] &amp;&amp; closedge[j].lowcost &lt; <span class="built_in">min</span>) &#123;</span><br><span class="line">				k = j;</span><br><span class="line">				<span class="built_in">min</span> = closedge[j].lowcost;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!visit[k])</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%c %c\n"</span>, closedge[k].adjvex+<span class="string">'a'</span><span class="number">-1</span>, k+<span class="string">'a'</span><span class="number">-1</span>);</span><br><span class="line">		closedge[k].lowcost = <span class="number">0</span>;</span><br><span class="line">		visit[k] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= G-&gt;vexnum; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (G-&gt;arcs[k][j] &lt; closedge[j].lowcost) &#123;</span><br><span class="line">				closedge[j] = &#123;k, G-&gt;arcs[k][j]&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	Graph G;</span><br><span class="line">	CreateGraph(G);</span><br><span class="line">	MiniSpanTree(G, <span class="string">'a'</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://ibb.co/jgZ65NW" target="_blank" rel="noopener"><img src="https://i.ibb.co/HnpF2Sx/image-20191121103616151.png" alt="image-20191121103616151" border="0"></a></p>
<p><img src="https://i.ibb.co/wpBFVRS/image-20191121104344422.png" alt=""></p>
<h6 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A| B C</span><br><span class="line">B| A C D E</span><br><span class="line">C| A B D H</span><br><span class="line">D| B C E F G H</span><br><span class="line">E| B D F</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>98.验证二叉搜索树</title>
    <url>/2019/11/17/LeetCode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<p>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h6 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h6><ul>
<li><p>输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  2</span><br><span class="line"> &#x2F;  \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出: true</p>
<h6 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h6></li>
<li><p>输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   4</span><br><span class="line">    &#x2F;  \</span><br><span class="line">  3    6</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出: false</p>
<h6 id="解释-输入为-5-1-4-null-null-3-6-。"><a href="#解释-输入为-5-1-4-null-null-3-6-。" class="headerlink" title="解释: 输入为: [5,1,4,null,null,3,6]。"></a>解释: 输入为: [5,1,4,null,null,3,6]。</h6><p>   根节点的值为 5 ，但是其右子节点值为 4 。</p>
</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(struct TreeNode *root, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">// printf("current low:%d\ncurrent up:%d\n", lower, upper);</span></span><br><span class="line">	<span class="keyword">if</span> (lower != <span class="number">-1</span> &amp;&amp; lower &gt;= root-&gt;val)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (upper != <span class="number">-1</span> &amp;&amp; upper &lt;= root-&gt;val)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (!helper(root-&gt;right, root-&gt;val, upper))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (!helper(root-&gt;left, lower, root-&gt;val))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(struct TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root,<span class="number">-1</span>,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><p>执行用时 :<br>8 ms, 在所有 c 提交中击败了94.16%的用户</p>
<p>内存消耗 :9.9 MB, 在所有 c 提交中击败了100.00%的用户</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>105.从前序与中序遍历序列构造二叉树</title>
    <url>/2019/11/17/LeetCode-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal" target="_blank" rel="noopener">题目链接</a></p>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<ul>
<li><p>注意:<br>你可以假设树中没有重复的元素。</p>
</li>
<li><p>例如，给出</p>
</li>
</ul>
<p>前序遍历 preorder = [3,9,20,15,7]<br>中序遍历 inorder = [9,3,15,20,7]<br>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre_order;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in_order;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="keyword">int</span> pre_idx = <span class="number">0</span>;</span><br><span class="line"><span class="function">TreeNode* <span class="title">help</span><span class="params">(<span class="keyword">int</span> inleft, <span class="keyword">int</span> inright)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (inleft == inright)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> root_val = pre_order[pre_idx];</span><br><span class="line">	TreeNode *root = <span class="keyword">new</span> TreeNode(root_val);</span><br><span class="line">	<span class="keyword">int</span> index = m[root_val];</span><br><span class="line">	pre_idx++;</span><br><span class="line">	root-&gt;left = help(inleft, index);</span><br><span class="line">	root-&gt;right = help(index + <span class="number">1</span>, inright);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">	pre_order = preorder;</span><br><span class="line">	in_order = inorder;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)inorder.size(); i++) &#123;</span><br><span class="line">		m[inorder[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> help(<span class="number">0</span>,(<span class="keyword">int</span>)preorder.size());</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h3><ul>
<li>执行用时 :<br>32 ms, 在所有 cpp 提交中击败了56.63%的用户</li>
<li>内存消耗 :</li>
</ul>
<p>19.2 MB, 在所有 cpp 提交中击败了24.87%的用户</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>无向图的遍历</title>
    <url>/2019/11/15/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ul>
<li>分别使用邻接表和邻接矩阵存储无向图图，并设计深度优先搜索遍历算法和广度优先搜索遍历算法。</li>
<li>用1,2,3，…，表示结点</li>
<li>并分别求出深度优先生成树和广度优先生成树的边集。</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h6 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM 31</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> VertexType;</span><br><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">bool</span> dfs_arc[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">bool</span> bfs_arc[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> adjvex;</span><br><span class="line">	ArcNode *nextarc;</span><br><span class="line">	InfoType *info;</span><br><span class="line">&#125; ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span> &#123;</span></span><br><span class="line">	VertexType data;</span><br><span class="line">	ArcNode *firstarc;</span><br><span class="line">&#125; VNode, AdjList[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	AdjList vertices;</span><br><span class="line">	<span class="keyword">int</span> vexnum, arcnum;</span><br><span class="line">	<span class="keyword">int</span> kind;</span><br><span class="line">&#125; ALGraph;</span><br><span class="line"><span class="comment">//创建无向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create</span><span class="params">(ALGraph &amp;G)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"输入节点数和边数"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;G.vexnum, &amp;G.arcnum);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= G.vexnum; i++) &#123;</span><br><span class="line">		G.vertices[i].data = i;</span><br><span class="line">		G.vertices[i].firstarc = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"依次输入弧"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= G.arcnum; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> v1, v2;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;v1, &amp;v2);</span><br><span class="line">		ArcNode *p = (ArcNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">		p-&gt;adjvex = v2;</span><br><span class="line">		p-&gt;nextarc = G.vertices[v1].firstarc;</span><br><span class="line">		G.vertices[v1].firstarc = p;</span><br><span class="line">		p = (ArcNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArcNode));</span><br><span class="line">		p-&gt;adjvex = v1;</span><br><span class="line">		p-&gt;nextarc = G.vertices[v2].firstarc;</span><br><span class="line">		G.vertices[v2].firstarc = p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(ALGraph *G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	ArcNode *p;</span><br><span class="line">	visited[v] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"当前DFS节点为%d\n"</span>, G-&gt;vertices[v].data);</span><br><span class="line">	p = G-&gt;vertices[v].firstarc;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!visited[p-&gt;adjvex]) &#123;</span><br><span class="line">			dfs_arc[v][p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">			dfs_arc[p-&gt;adjvex][v] = <span class="number">1</span>;</span><br><span class="line">			DFS(G, p-&gt;adjvex);</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;nextarc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_traverse</span><span class="params">(ALGraph *G)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= G-&gt;vexnum; k++)</span><br><span class="line">		visited[k] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"DFS"</span>);</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"请输入DFS起点"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">	DFS(G, v);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"DFS生成树边集:"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= G-&gt;vexnum; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= G-&gt;vexnum; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dfs_arc[i][j])</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_traverse</span><span class="params">(ALGraph *G)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"BFS"</span>);</span><br><span class="line">	<span class="keyword">int</span> Q[MAX_VERTEX_NUM];</span><br><span class="line">	<span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> rear = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= G-&gt;vexnum; k++)</span><br><span class="line">		visited[k] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"请输入BFS起点"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"当前BFS节点为%d\n"</span>, v);</span><br><span class="line">	visited[v] = <span class="number">1</span>;</span><br><span class="line">	Q[++rear] = v;</span><br><span class="line">	<span class="keyword">while</span> (front != rear) &#123;</span><br><span class="line">		<span class="keyword">int</span> w = Q[++front];</span><br><span class="line">		ArcNode *p = G-&gt;vertices[w].firstarc;</span><br><span class="line">		<span class="keyword">while</span> (p) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!visited[p-&gt;adjvex]) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"当前BFS节点为%d\n"</span>, p-&gt;adjvex);</span><br><span class="line">				visited[p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">				Q[++rear] = p-&gt;adjvex;</span><br><span class="line">				bfs_arc[w][p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">				bfs_arc[p-&gt;adjvex][w] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			p = p-&gt;nextarc;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"BFS生成树边集："</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= G-&gt;vexnum; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= G-&gt;vexnum; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (bfs_arc[i][j])</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	ALGraph G;</span><br><span class="line">	Create(G);</span><br><span class="line">	DFS_traverse(&amp;G);</span><br><span class="line">	BFS_traverse(&amp;G);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> arc[MAX][MAX];</span><br><span class="line"><span class="keyword">bool</span> visit[MAX];</span><br><span class="line"><span class="keyword">bool</span> dfs_arc[MAX][MAX];</span><br><span class="line"><span class="keyword">bool</span> bfs_arc[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v &lt;= n)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, v);</span><br><span class="line">	visit[v] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arc[v][i] == <span class="number">1</span> &amp;&amp; visit[i] == <span class="number">0</span>) &#123;</span><br><span class="line">			dfs_arc[v][i] = <span class="number">1</span>;</span><br><span class="line">			dfs_arc[i][v] = <span class="number">1</span>;</span><br><span class="line">			dfs(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_traverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		visit[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"请输入DFS起点"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;v);</span><br><span class="line">	dfs(v);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"DFS生成树边集为"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dfs_arc[i][j])</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs_traverse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		visit[i] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"请输入BFS起点"</span>);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; v;</span><br><span class="line">	Q.push(v);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, v);</span><br><span class="line">	visit[v] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		v = Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arc[v][i] == <span class="number">1</span> &amp;&amp; !visit[i]) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">				bfs_arc[v][i] = <span class="number">1</span>;</span><br><span class="line">				bfs_arc[i][v] = <span class="number">1</span>;</span><br><span class="line">                Q.push(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"BFS生成树边集为"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (bfs_arc[i][j])</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"输入节点数和边数"</span>);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">int</span> v1, v2;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"依次输入各边"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">		arc[v1][v2] = <span class="number">1</span>;</span><br><span class="line">		arc[v2][v1] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs_traverse();</span><br><span class="line">	bfs_traverse();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>求元素子树深度</title>
    <url>/2019/11/13/%E6%B1%82%E5%85%83%E7%B4%A0%E5%AD%90%E6%A0%91%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>请设计递归算法求以元素为x根节点的子树深度</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	Node *left;</span><br><span class="line">	Node *right;</span><br><span class="line">&#125; * BTree;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">createBTree</span><span class="params">(BTree &amp;T)</span> </span>&#123;</span><br><span class="line">	ElemType c;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;c);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">' '</span>) T = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(T = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node))))</span><br><span class="line">			<span class="keyword">return</span> ERROR;</span><br><span class="line">		T-&gt;data = c;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"请输入%c的左孩子\n"</span>, c);</span><br><span class="line">		createBTree(T-&gt;left);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"请输入%c的右孩子\n"</span>, c);</span><br><span class="line">		createBTree(T-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(BTree T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> getDepth(T-&gt;left) &gt; getDepth(T-&gt;right) ? getDepth(T-&gt;left) + <span class="number">1</span> : getDepth(T-&gt;right) + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getChildDepth</span><span class="params">(BTree T, ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		<span class="keyword">if</span> (T-&gt;data == e) &#123;</span><br><span class="line">			<span class="keyword">return</span> getDepth(T);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> m = getChildDepth(T-&gt;left, e);</span><br><span class="line">			<span class="keyword">int</span> n = getChildDepth(T-&gt;right, e);</span><br><span class="line">			<span class="keyword">return</span> m &gt;= n ? m : n;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BTree T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c\n"</span>, T-&gt;data);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	preOrder(T-&gt;left);</span><br><span class="line">	preOrder(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	BTree T;</span><br><span class="line">	createBTree(T);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getChildDepth(T, <span class="string">'3'</span>));</span><br><span class="line">	preOrder(T);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>哈夫曼编码及译码器</title>
    <url>/2019/11/10/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%8F%8A%E8%AF%91%E7%A0%81%E5%99%A8/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>利用哈夫曼编码进行通信可以大大提高信道利用率,缩短信息传输时间,降低传输成本。但是,这要求在发送端通过一个编码系统对待传数据预先码,在接收端将传来的数据进行译码(复原)。对于双工信道(即可以双向传输信息的信道),每端需要一个完编/译码系统。试为这样的信息收发站写一个哈夫曼码的编/译码系统。</p>
<h3 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h3><p>一个完整的系统应具有以下功能:</p>
<ol>
<li>I :初始化(Initialization)。从终端读人字符集大小n,以及n个字符和n个权值,建立哈夫曼树,并将它存于文件 hfmTree 中。</li>
<li>E :编码(Encoding)。利用以建好的哈夫曼树(如不在内存,则从文件 hfmTree 中读人),对文件 ToBeTran 中的正文进行编码,然后将结果存人文件 CodeFile 中。</li>
<li>D :译 码(Decoding)。利用已建好的哈夫曼树将文件 CodeFile 中的代码进行译码,结果存人文件 TextFile 中。</li>
<li>P :印代码文件(Print)。将文件 CodeFile 以紧凑格式显示在终端上,每行50个代码。同时将此字符形式的编码文件写人文件 CodePrin。</li>
<li>T :打印哈夫曼树(Tree printing)。将已在内存中的哈夫曼树以直观的方式(树或凹人表形式)显示在终端上,同时将此字符形式的哈夫曼树写人文件 TreePrint 中。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX 2147483647</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">int</span> parent;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">    <span class="keyword">char</span> *code;</span><br><span class="line">&#125; HNode;</span><br><span class="line">HNode *T;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function">Status <span class="title">select</span><span class="params">(HNode *T, <span class="keyword">int</span> pos, <span class="keyword">int</span> *s1, <span class="keyword">int</span> *s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m1, m2;</span><br><span class="line">    m1 = m2 = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pos; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (T[j].weight &lt; m1 &amp;&amp; T[j].parent == <span class="number">0</span>) &#123;</span><br><span class="line">            m2 = m1;</span><br><span class="line">            *s2 = *s1;</span><br><span class="line">            *s1 = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T[j].weight &lt; m2 &amp;&amp; T[j].parent == <span class="number">0</span>) &#123;</span><br><span class="line">            m2 = T[j].weight;</span><br><span class="line">            *s2 = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Initialization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">"hfmTree.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"请输入n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">"%d\n"</span>, n);</span><br><span class="line">    T = <span class="keyword">new</span> HNode[<span class="number">2</span> * n];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"请输入n个字符及其权值"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        getchar();</span><br><span class="line">        T[i].c = getchar();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %d"</span>, &amp;T[i].weight);</span><br><span class="line">        T[i].parent = <span class="number">0</span>;</span><br><span class="line">        T[i].left = <span class="number">0</span>;</span><br><span class="line">        T[i].right = <span class="number">0</span>;</span><br><span class="line">        T[i].code = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        T[i].c = <span class="string">'^'</span>;</span><br><span class="line">        T[i].weight = <span class="number">0</span>;</span><br><span class="line">        T[i].parent = <span class="number">0</span>;</span><br><span class="line">        T[i].left = <span class="number">0</span>;</span><br><span class="line">        T[i].right = <span class="number">0</span>;</span><br><span class="line">        T[i].code = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s1, s2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        select(T, i - <span class="number">1</span>, &amp;s1, &amp;s2);</span><br><span class="line">        T[i].weight = T[s1].weight + T[s2].weight;</span><br><span class="line">        T[s1].parent = T[s2].parent = i;</span><br><span class="line">        T[i].left = s1;</span><br><span class="line">        T[i].right = s2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(fp, <span class="string">"%c %d %d %d %d\n"</span>, T[i].c, T[i].weight, T[i].parent,</span><br><span class="line">                T[i].left, T[i].right);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Encoding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) &#123;</span><br><span class="line">        FILE *fp = fopen(<span class="string">"hfmTree.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">        <span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%c %d %d %d %d"</span>, &amp;T[i].c, &amp;T[i].weight, &amp;T[i].parent,</span><br><span class="line">                   &amp;T[i].left, &amp;T[i].right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *cd;</span><br><span class="line">    cd = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * n);</span><br><span class="line">    cd[n - <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = i;</span><br><span class="line">        <span class="keyword">int</span> p = T[i].parent;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            --start;</span><br><span class="line">            <span class="keyword">if</span> (T[p].left == c)</span><br><span class="line">                cd[start] = <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cd[start] = <span class="string">'1'</span>;</span><br><span class="line">            c = p;</span><br><span class="line">            p = T[p].parent;</span><br><span class="line">        &#125;</span><br><span class="line">        T[i].code = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((n - start) * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">        <span class="built_in">strcpy</span>(T[i].code, &amp;cd[start]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(cd);</span><br><span class="line">    FILE *pf = fopen(<span class="string">"ToBeTran.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    FILE *p = fopen(<span class="string">"CodeFile.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">char</span> t;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(pf, <span class="string">"%c"</span>, &amp;t) != EOF) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t == T[i].c) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(p, <span class="string">"%s"</span>, T[i].code);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(pf);</span><br><span class="line">    fclose(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Decoding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T) &#123;</span><br><span class="line">        FILE *fp = fopen(<span class="string">"hfmTree.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">        <span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">            <span class="built_in">fscanf</span>(fp, <span class="string">"%c %d %d %d %d"</span>, &amp;T[i].c, &amp;T[i].weight, &amp;T[i].parent,</span><br><span class="line">                   &amp;T[i].left, &amp;T[i].right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FILE *fp = fopen(<span class="string">"CodeFile.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    FILE *fp1 = fopen(<span class="string">"TextFile.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">char</span> t;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">"%c"</span>, &amp;t) != EOF) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span> * n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((T[i].left != <span class="number">0</span> || T[i].right != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">2</span> * n - <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">fscanf</span>(fp, <span class="string">"%c"</span>, &amp;t);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="string">'0'</span>) &#123;</span><br><span class="line">                i = T[i].left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="string">'1'</span>)</span><br><span class="line">                i = T[i].right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (T[i].left == <span class="number">0</span> &amp;&amp; T[i].right == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(fp1, <span class="string">"%c"</span>, T[i].c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    fclose(fp1);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">"CodeFile.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    FILE *fp1 = fopen(<span class="string">"CodePrin.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">char</span> t;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(fp, <span class="string">"%c"</span>, &amp;t) != EOF) &#123;</span><br><span class="line">        ++i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, t);</span><br><span class="line">        <span class="built_in">fprintf</span>(fp1, <span class="string">"%c"</span>, t);</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">50</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            <span class="built_in">fprintf</span>(fp1, <span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    fclose(fp1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tree_printing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">"TreePrint.txt"</span>, <span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"T[i].c:%c\tT[i].weight:%d\tT[i].parent:%d\tT[i].left:%d\tT[i]."</span></span><br><span class="line">               <span class="string">"right:%d\n"</span>,</span><br><span class="line">               T[i].c, T[i].weight, T[i].parent, T[i].left, T[i].right);</span><br><span class="line">        <span class="built_in">fprintf</span>(fp,</span><br><span class="line">                <span class="string">"T[i].c:%c\tT[i].weight:%d\tT[i].parent:%d\tT[i].left:%d\tT[i]."</span></span><br><span class="line">                <span class="string">"right:%d\n"</span>,</span><br><span class="line">                T[i].c, T[i].weight, T[i].parent, T[i].left, T[i].right);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入0结束程序\n输入1初始化\n输入2进行编码\n输入3进行译码\n输入4打印代码文件\n输入5打印哈夫曼树\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">    Initialization();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">    Encoding();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">3</span>)</span><br><span class="line">    Decoding();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">4</span>)</span><br><span class="line">    Print();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">5</span>)</span><br><span class="line">    Tree_printing();</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>哈夫曼树和哈夫曼编码</title>
    <url>/2019/11/07/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h3 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h3><p>Huffman树是一种特殊结构的二叉树，由Huffman树设计的二进制前缀编码，也称为Huffman编码在通信领域有着广泛的应用。</p>
<ol>
<li><p>路径长度<br>路径长度指的是路径上分支的数目，在上图中，路径长度为2。</p>
</li>
<li><p>节点的权<br>节点的权指的是为树中的每一个节点赋予的一个非负的值，如上图中每一个节点中的值。</p>
</li>
<li><p>节点的带权路径长度<br>节点的带权路径长度指的是从根节点到该节点之间的路径长度与该节点权的乘积：如对于1节点的带权路径长度为：2。</p>
</li>
<li><p>树的带权路径长度<br>树的带权路径长度指的是所有叶子节点的带权路径长度之和。</p>
</li>
</ol>
<blockquote>
<p>有了如上的概念，对于Huffman树，其定义为：<br>给定nn权值作为nn个叶子节点，构造一棵二叉树，若这棵二叉树的带权路径长度达到最小，则称这样的二叉树为最优二叉树，也称为Huffman树。</p>
</blockquote>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>重复以下的步骤：</p>
<ol>
<li>按照权值对每一个节点排序：D-F-T-E-R-A</li>
<li>选择权值最小的两个节点，此处为D和F生成新的节点，节点的权重这两个节点的权重之和，为2</li>
<li>直到只剩最后的根节点</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h6 id="readfile"><a href="#readfile" class="headerlink" title="readfile"></a>readfile</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_file</span><span class="params">(FILE *fn, <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &amp;word)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fn == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">char</span> line[MAXSIZE];</span><br><span class="line">	<span class="keyword">while</span> (fgets(line, <span class="number">1024</span>, fn)) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, line);</span><br><span class="line">		<span class="keyword">char</span> *p = line;</span><br><span class="line">		<span class="keyword">while</span> (*p != <span class="string">'\0'</span> &amp;&amp; *p != <span class="string">'\n'</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (word.find(*p) == word.end()) &#123;</span><br><span class="line">				word[*p] = <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				word[*p]++;</span><br><span class="line">			&#125;</span><br><span class="line">			p++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"readfile.cc"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 500</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HuffmanNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">int</span> weight;</span><br><span class="line">	<span class="keyword">char</span> huffman_code[LEN];</span><br><span class="line">	HuffmanNode *left;</span><br><span class="line">	HuffmanNode *right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sort_by_weight</span><span class="params">(HuffmanNode *n1, HuffmanNode *n2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n1-&gt;weight &lt; n2-&gt;weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">huffman_tree_create</span><span class="params">(HuffmanNode *&amp;root, <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; &amp;word)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> line[MAXSIZE];</span><br><span class="line">	<span class="built_in">vector</span>&lt;HuffmanNode*&gt; huffman_tree;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span> (it = word.begin(); it != word.end(); it++) &#123;</span><br><span class="line">		HuffmanNode *node = (HuffmanNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HuffmanNode));</span><br><span class="line">		node-&gt;c = it-&gt;first;</span><br><span class="line">		node-&gt;weight = it-&gt;second;</span><br><span class="line">		node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">		node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">		huffman_tree.push_back(node);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (huffman_tree.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		sort(huffman_tree.begin(), huffman_tree.end(), sort_by_weight);</span><br><span class="line">		<span class="keyword">if</span> (huffman_tree.size() == <span class="number">1</span>) &#123;</span><br><span class="line">			root = huffman_tree[<span class="number">0</span>];</span><br><span class="line">			huffman_tree.erase(huffman_tree.begin());</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			HuffmanNode *n1 = huffman_tree[<span class="number">0</span>];</span><br><span class="line">			HuffmanNode *n2 = huffman_tree[<span class="number">1</span>];</span><br><span class="line">			huffman_tree.erase(huffman_tree.begin(), huffman_tree.begin() + <span class="number">2</span>);</span><br><span class="line">			HuffmanNode *n3 = (HuffmanNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HuffmanNode));</span><br><span class="line">			n3-&gt;weight = n1-&gt;weight + n2-&gt;weight;</span><br><span class="line">			(n1-&gt;weight &lt; n2-&gt;weight) ? (n3-&gt;left = n1, n3-&gt;right = n2) : (n3-&gt;left = n2, n3-&gt;right = n1);</span><br><span class="line">			huffman_tree.push_back(n3);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(HuffmanNode *node)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c\t%d\n"</span>, node-&gt;c, node-&gt;weight);</span><br><span class="line">		traverse(node-&gt;left);</span><br><span class="line">		traverse(node-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">huffman_coding</span><span class="params">(HuffmanNode *&amp;node)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	HuffmanNode *p = node;</span><br><span class="line">	<span class="built_in">queue</span>&lt;HuffmanNode*&gt; q;</span><br><span class="line">	q.push(p);</span><br><span class="line">	<span class="keyword">while</span> (q.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		p = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			q.push(p-&gt;left);</span><br><span class="line">			<span class="built_in">strcpy</span>((p-&gt;left)-&gt;huffman_code, p-&gt;huffman_code);</span><br><span class="line">			<span class="keyword">char</span> *pp = (p-&gt;left)-&gt;huffman_code;</span><br><span class="line">			<span class="keyword">while</span> (*pp != <span class="string">'\0'</span>) &#123;</span><br><span class="line">				pp++;</span><br><span class="line">			&#125;</span><br><span class="line">			*pp = <span class="string">'0'</span>;</span><br><span class="line">			*++pp = <span class="string">'\0'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			q.push(p-&gt;right);</span><br><span class="line">			<span class="built_in">strcpy</span>((p-&gt;right)-&gt;huffman_code, p-&gt;huffman_code);</span><br><span class="line">			<span class="keyword">char</span> *pp = (p-&gt;right)-&gt;huffman_code;</span><br><span class="line">			<span class="keyword">while</span> (*pp != <span class="string">'\0'</span>) &#123;</span><br><span class="line">				pp++;</span><br><span class="line">			&#125;</span><br><span class="line">			*pp = <span class="string">'1'</span>;</span><br><span class="line">			*++pp = <span class="string">'\0'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_leaf</span><span class="params">(HuffmanNode *node)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		print_leaf(node-&gt;left);</span><br><span class="line">		<span class="keyword">if</span> (node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%c  %s\n"</span>, node-&gt;c, node-&gt;huffman_code);</span><br><span class="line">		print_leaf(node-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	FILE *fn = fopen(<span class="string">"huffman.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; word;</span><br><span class="line">	HuffmanNode *root = <span class="literal">NULL</span>;</span><br><span class="line">	read_file(fn, word);</span><br><span class="line">	fclose(fn);</span><br><span class="line">	huffman_tree_create(root, word);</span><br><span class="line">	<span class="comment">// traverse(root);</span></span><br><span class="line">	huffman_coding(root);</span><br><span class="line">	print_leaf(root);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>魔王语言解释</title>
    <url>/2019/11/06/%E9%AD%94%E7%8E%8B%E8%AF%AD%E8%A8%80%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>有一个魔王总是使用自己的一种非常精练而抽象的语言讲话，没人能听的懂。但他的语言是可以逐步解释成人能懂得语言的，因为他的语言是由以下两种形式的规则由人的语言逐 步抽象上去的： </p>
<ul>
<li>（1）α-&gt;β1β2…βn</li>
<li>（2）(θδ1δ2…δn)-&gt;θδnθδn-1…θδ1θ<blockquote>
<p>在这两种形式中，从左到右均表示解释；从右到左表示抽象。试写一个魔王解释系统，把他的话解释成人能听懂得话。   </p>
</blockquote>
</li>
</ul>
<h3 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h3><p>用下述两条具体规则和上述规则实现。设大写字母表示魔王语言的词汇；小写字母表示人的语言词汇；希腊字母（a,b1,s,y1等）表示可以用大写或小写字母代换的变量。魔王语言可含人的词汇。</p>
<ul>
<li>(1)   B-&gt;tAdA</li>
<li>(2)   A-&gt;sae   </li>
</ul>
<h3 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h3><p>B（ehnxgz）B 解释成tsaedsaeezegexeneietsaedsae<br>若将小写字母与汉字建立下表所示的对应关系，则魔王说的话是“天上一个鹅地上一个鹅鹅追鹅赶鹅下鹅蛋鹅恨鹅天上一个鹅地上一个鹅。”<br>t  d  s  a   e z  g  x  n i<br>天 地 上 一个 鹅 追 赶 下 蛋 恨</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> c, <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; &amp;S, <span class="built_in">string</span> &amp;str)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c"</span>, c);</span><br><span class="line">		str += c;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'A'</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"sae"</span>);</span><br><span class="line">		str += <span class="string">"sae"</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'B'</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"tsaedsae"</span>);</span><br><span class="line">		str += <span class="string">"tsaedsae"</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">		<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; SS;</span><br><span class="line">		S.pop();</span><br><span class="line">		<span class="keyword">char</span> t = S.top();</span><br><span class="line">		S.pop();</span><br><span class="line">		<span class="keyword">while</span> (S.top() != <span class="string">')'</span>) &#123;</span><br><span class="line">			SS.push(S.top());</span><br><span class="line">			S.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!SS.empty()) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%c"</span>, t);</span><br><span class="line">			str += t;</span><br><span class="line">			solve(SS.top(), S, str);</span><br><span class="line">			SS.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c"</span>, t);</span><br><span class="line">		str += t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">translate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)s.length(); i++) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (s[i]) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'t'</span>: <span class="built_in">cout</span> &lt;&lt; <span class="string">"天"</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'d'</span>: <span class="built_in">cout</span> &lt;&lt; <span class="string">"地"</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'s'</span>: <span class="built_in">cout</span> &lt;&lt; <span class="string">"上"</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'a'</span>: <span class="built_in">cout</span> &lt;&lt; <span class="string">"一只"</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'e'</span>: <span class="built_in">cout</span> &lt;&lt; <span class="string">"鹅"</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'z'</span>: <span class="built_in">cout</span> &lt;&lt; <span class="string">"追"</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'g'</span>: <span class="built_in">cout</span> &lt;&lt; <span class="string">"赶"</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'x'</span>: <span class="built_in">cout</span> &lt;&lt; <span class="string">"下"</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'n'</span>: <span class="built_in">cout</span> &lt;&lt; <span class="string">"蛋"</span>; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'h'</span>: <span class="built_in">cout</span> &lt;&lt; <span class="string">"恨"</span>; <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">	reverse(s.begin(), s.end());</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; S;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)s.length(); i++) &#123;</span><br><span class="line">		S.push(s[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">string</span> str = <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">while</span> (!S.empty()) &#123;</span><br><span class="line">		solve(S.top(), S, str);</span><br><span class="line">		S.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	translate(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFEASIBLE -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType elem[MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(Stack &amp;S)</span> </span>&#123;</span><br><span class="line">	S.top = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(Stack &amp;S, ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (S.top &gt;= <span class="number">100</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	S.elem[++S.top] = e;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(Stack &amp;S, ElemType *e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (S.top == <span class="number">-1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">	*e = S.elem[S.top--];</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">IsEmpty</span><span class="params">(Stack S)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> S.top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span> c, Stack &amp;S)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c"</span>, c);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'A'</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"sae"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'B'</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"tsaedsae"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">		Stack SS;</span><br><span class="line">		InitStack(SS);</span><br><span class="line">		<span class="keyword">char</span> t;</span><br><span class="line">		<span class="keyword">char</span> tmp;</span><br><span class="line">		Pop(S, &amp;tmp);</span><br><span class="line">		Pop(S, &amp;t);</span><br><span class="line">		<span class="keyword">while</span> (S.elem[S.top] != <span class="string">')'</span>) &#123;</span><br><span class="line">			Push(SS, S.elem[S.top]);</span><br><span class="line">			Pop(S, &amp;tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!IsEmpty(SS)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%c"</span>, t);</span><br><span class="line">			solve(SS.elem[SS.top], S);</span><br><span class="line">			Pop(SS, &amp;tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c"</span>, t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	Stack S, S1;</span><br><span class="line">	InitStack(S);</span><br><span class="line">	InitStack(S1);</span><br><span class="line">	<span class="keyword">char</span> *s;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)<span class="built_in">strlen</span>(s); i++) &#123;</span><br><span class="line">		Push(S, s[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)<span class="built_in">strlen</span>(s); i++) &#123;</span><br><span class="line">		<span class="keyword">char</span> tmp;</span><br><span class="line">		Pop(S, &amp;tmp);</span><br><span class="line">		Push(S1, tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span> t;</span><br><span class="line">	<span class="keyword">while</span> (!IsEmpty(S1)) &#123;</span><br><span class="line">		solve(S1.elem[S1.top], S1);</span><br><span class="line">		Pop(S1, &amp;t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>约瑟夫环问题</title>
    <url>/2019/11/06/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>编号为1, 2, 3,…,n的n个人围成一圈，每个人持有一个密码（正整数），从初始m为上限从1开始报数，报到m为止，报m的出列，将他的密码作为下一个m值，如此下去，求出出列顺序。</p>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>很容易想到用循环链表来解决该问题</p>
<h3 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h3><h5 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 20</span><br><span class="line">3 1 7 2 4 8 4</span><br></pre></td></tr></table></figure>
<h5 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">7</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h5 id="Clang"><a href="#Clang" class="headerlink" title="Clang"></a>Clang</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	Node *next;</span><br><span class="line">&#125; * LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	Node *node, *<span class="built_in">end</span>;</span><br><span class="line">	<span class="built_in">end</span> = L;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;node-&gt;data);</span><br><span class="line">		node-&gt;id = i + <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">end</span>-&gt;next = node;</span><br><span class="line">		<span class="built_in">end</span> = node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">end</span>-&gt;next = L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m &lt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> t = m;</span><br><span class="line">	Node *last = L-&gt;next;</span><br><span class="line">	Node *cur = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (cur-&gt;next != cur) &#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; t - <span class="number">1</span>) &#123;</span><br><span class="line">			last = cur;</span><br><span class="line">			cur = cur-&gt;next;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		Node *p = cur;</span><br><span class="line">		t = cur-&gt;data;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cur-&gt;id);</span><br><span class="line">		last-&gt;next = cur-&gt;next;</span><br><span class="line">		cur = last-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cur-&gt;id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	LinkList L;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	Create(L, n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,solve(L, m));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> pw[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pw[i]);</span><br><span class="line">        l.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = l.begin();</span><br><span class="line">    <span class="keyword">while</span> (!l.empty()) &#123;</span><br><span class="line">        m %= (<span class="keyword">int</span>)l.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            it++;</span><br><span class="line">            <span class="keyword">if</span> (it == l.end())</span><br><span class="line">                it = l.begin();</span><br><span class="line">        &#125;</span><br><span class="line">        m = pw[*it];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        it = l.erase(it);</span><br><span class="line">        <span class="keyword">if</span> (it == l.end())</span><br><span class="line">            it = l.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read();</span><br><span class="line">    solve(m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的创建和遍历</title>
    <url>/2019/10/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>用C语言实现二叉树的表示及非递归中序遍历算法（没啥说的直接上代码）</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFEASIBLE -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, * BiTree;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T)</span> </span>&#123;</span><br><span class="line">	ElemType ch;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;ch);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">if</span> (ch == <span class="string">' '</span>) T = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(T = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode)))) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		T-&gt;data = ch;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"输入%c的左孩子\n"</span>, T-&gt;data);</span><br><span class="line">		CreateBiTree(T-&gt;lchild);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"输入%c的右孩子\n"</span>, T-&gt;data);</span><br><span class="line">		CreateBiTree(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历二叉树的非递归算法</span></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree T, Status (*Visit)(ElemType e))</span> </span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;BiTNode*&gt; S;</span><br><span class="line">	S.push(T);</span><br><span class="line">	BiTNode *p;</span><br><span class="line">	<span class="keyword">while</span> (!S.empty()) &#123;</span><br><span class="line">		<span class="keyword">while</span> (p = S.top()) S.push(p-&gt;lchild);</span><br><span class="line">		p = S.top();</span><br><span class="line">		S.pop();</span><br><span class="line">		<span class="keyword">if</span> (!S.empty()) &#123;</span><br><span class="line">			p = S.top();</span><br><span class="line">			S.pop();</span><br><span class="line">			<span class="keyword">if</span> (!Visit(p-&gt;data))</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			S.push(p-&gt;rchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Visit</span><span class="params">(ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%c\n"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	BiTree T;</span><br><span class="line">	CreateBiTree(T);</span><br><span class="line">	InOrderTraverse(T, Visit);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>编程</tag>
        <tag>栈</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>链栈</title>
    <url>/2019/10/23/%E9%93%BE%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>链栈一般用一个头指针结构top来表示，它指向栈顶元素，对于链表来说，top结构相当于它的头指针head。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Node *top;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">&#125; * Stack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(Stack &amp;s)</span> </span>&#123;</span><br><span class="line">	s-&gt;top = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	<span class="keyword">if</span> (!s-&gt;top) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"ERROR"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">	s-&gt;count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack &amp;s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">	Node *node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	node-&gt;data = e;</span><br><span class="line">	node-&gt;next = s-&gt;top;</span><br><span class="line">	s-&gt;top = node;</span><br><span class="line">	s-&gt;count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(Stack &amp;s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"Empty"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Node *t = s-&gt;top;</span><br><span class="line">	s-&gt;top = s-&gt;top-&gt;next;</span><br><span class="line">	<span class="keyword">int</span> e = t-&gt;data;</span><br><span class="line">	<span class="built_in">free</span>(t);</span><br><span class="line">	s-&gt;count--;</span><br><span class="line">	<span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearStack</span><span class="params">(Stack &amp;s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	Node *p, *q;</span><br><span class="line">	p = s-&gt;top;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		q = p;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(q);</span><br><span class="line">	&#125;</span><br><span class="line">	s-&gt;count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	Stack s;</span><br><span class="line">	InitStack(s);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		Push(s, i);</span><br><span class="line">	<span class="comment">// ClearStack(s);</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Pop(s));</span><br><span class="line">	Push(s, <span class="number">100</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Pop(s));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>编程</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>删除子串</title>
    <url>/2019/10/21/%E5%88%A0%E9%99%A4%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>删除s中所有与t相同的子串</p>
<blockquote>
<p>如 s = “abcdabcdabcd”, t = “cd”, 则操作后s = “ababab”</p>
</blockquote>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">GetNext</span><span class="params">(<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pLen = p.length();</span><br><span class="line">  <span class="keyword">int</span> *next = <span class="keyword">new</span> <span class="keyword">int</span>[pLen];</span><br><span class="line">  next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k]) &#123;</span><br><span class="line">      j++;</span><br><span class="line">      k++;</span><br><span class="line">      next[j] = k;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>* next =GetNext(p);</span><br><span class="line">  <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">  <span class="keyword">int</span> pLen = p.length();</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen) &#123;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j]) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      j++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (j == pLen) &#123;</span><br><span class="line">    s.erase(i-j, j);</span><br><span class="line">    solve(s, p);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> s, p;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; p;</span><br><span class="line">  solve(s, p);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>编程</tag>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title>求最长重复子串及其位置</title>
    <url>/2019/10/19/%E6%B1%82%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2%E5%8F%8A%E5%85%B6%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给出一个线性排列的串s，求出s中出现的第一个最长重复子串及其位置；并分析时间复杂度。</p>
<blockquote>
<p>例如 s = “abcdbcd”，它的第一个出现的最长重复子串及其位置分别为：”bcd，1”。</p>
</blockquote>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">GetNext</span><span class="params">(<span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pLen = p.length();</span><br><span class="line">	<span class="keyword">int</span>* next = <span class="keyword">new</span> <span class="keyword">int</span>[pLen];</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || p[k] == p[j]) &#123;</span><br><span class="line">			k++;</span><br><span class="line">			j++;</span><br><span class="line">			<span class="keyword">if</span> (p[k] != p[j]) &#123;</span><br><span class="line">				next[j] = k;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				next[j] = next[k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			k = next[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *next = GetNext(p);</span><br><span class="line">	<span class="keyword">int</span> sLen = s.length();</span><br><span class="line">	<span class="keyword">int</span> pLen = p.length();</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen) &#123;</span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j]) &#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			j = next[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (j == pLen)</span><br><span class="line">		<span class="keyword">return</span> i - pLen;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> &amp;p, <span class="keyword">int</span> &amp;pos)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sLen = s.length();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen / <span class="number">2</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = sLen / <span class="number">2</span> + <span class="number">1</span>; j &gt;= i + <span class="number">1</span>; j--) &#123;</span><br><span class="line">			<span class="built_in">string</span> prep = s.substr(i, j - i);</span><br><span class="line">			<span class="built_in">string</span> end = s.substr(j, sLen - j);</span><br><span class="line">			<span class="keyword">if</span> (KmpSearch(end, prep) != <span class="number">-1</span>) &#123;</span><br><span class="line">				p = prep;</span><br><span class="line">				pos = i;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pos = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">	<span class="built_in">string</span> p;</span><br><span class="line">	<span class="keyword">int</span> pos;</span><br><span class="line">	solve(s, p, pos);</span><br><span class="line">	<span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="string">' '</span> &lt;&lt; pos &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; pos &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>主要算法复杂度为O(n^2), 而其中的kmp算法时间复杂度为O(n),则整个算法复杂度为O(n^3)。</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>编程</tag>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2019/10/13/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="KMP算法描述"><a href="#KMP算法描述" class="headerlink" title="KMP算法描述"></a>KMP算法描述</h3><ol>
<li><p>算法流程</p>
<blockquote>
<p>设文本串匹配到i，模式串匹配到j</p>
</blockquote>
<ul>
<li>若j == -1或者匹配成功(s[i] == p[j])，则i++，j++；</li>
<li>若j != -1且匹配不成功，则j = next[j]（相当于模式串p相对于文本串s向右移动(j - next[j])位）。</li>
</ul>
</li>
<li><p>得到next数组</p>
<blockquote>
<p>next数组表示当前字符之前的字符串中，有多大长度的相同前缀后缀</p>
</blockquote>
</li>
</ol>
<p>对于P的前j+1个序列字符：</p>
<ul>
<li>若p[k] == p[j]，则next[j + 1 ] = next [j] + 1 = k + 1；</li>
<li>若p[k ] ≠ p[j]，如果此时p[ next[k] ] == p[j ]，则next[ j + 1 ] =  next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">GetNext</span><span class="params">(<span class="keyword">char</span>* p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span>* next = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">strlen</span>(p)];</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k]) &#123;</span><br><span class="line">			j++;</span><br><span class="line">			k++;</span><br><span class="line">			<span class="keyword">if</span> (p[j] != p[k]) &#123;</span><br><span class="line">				next[j] = k;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				next[j] = next[k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			k = next[k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KmpSearch</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* p, <span class="keyword">int</span> next[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> pLen = <span class="built_in">strlen</span>(p);</span><br><span class="line">	<span class="keyword">int</span> sLen = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen) &#123;</span><br><span class="line">		<span class="keyword">if</span> (j == <span class="number">-1</span> || s[i] == p[j]) &#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			j = next[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (j == pLen)</span><br><span class="line">		<span class="keyword">return</span> i - j;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">char</span> p[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, s, p) == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, KmpSearch(s, p, GetNext(p)));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kmp</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span>[] getNext(String p) &#123;</span><br><span class="line">		<span class="keyword">int</span> next[] = <span class="keyword">new</span> <span class="keyword">int</span>[p.length()];</span><br><span class="line">		next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (j &lt; p.length() - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (k == -<span class="number">1</span> || p.charAt(j) == p.charAt(k)) &#123;</span><br><span class="line">				j++;</span><br><span class="line">				k++;</span><br><span class="line">				<span class="keyword">if</span> (p.charAt(j) != p.charAt(k))</span><br><span class="line">					next[j] = k;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					next[j] = next[k];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				k = next[k];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmpSearch</span><span class="params">(String s, String p, <span class="keyword">int</span> []next)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; p.length()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j == -<span class="number">1</span> || s.charAt(i) == p.charAt(j)) &#123;</span><br><span class="line">				i++;</span><br><span class="line">				j++;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				j = next[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (j == p.length())</span><br><span class="line">			<span class="keyword">return</span> i - j;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String s = <span class="string">"abacababc"</span>;</span><br><span class="line">		String p = <span class="string">"abab"</span>;</span><br><span class="line">		System.out.println(kmpSearch(s, p, getNext(p)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>编程</tag>
        <tag>C/Java</tag>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title>循环队列</title>
    <url>/2019/10/10/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>如果希望循环队列的每一个元素都能用到，需设置一个标志域tag，用tag的0或1来区分是否满队列。试写出这种结构的算法，并从时间和空间分析这两种这两种方法的适用范围。</p>
<h3 id="带标志域（tag）的算法实现"><a href="#带标志域（tag）的算法实现" class="headerlink" title="带标志域（tag）的算法实现"></a>带标志域（tag）的算法实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFEASIBLE -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType *base;</span><br><span class="line">	<span class="keyword">int</span> front;</span><br><span class="line">	<span class="keyword">int</span> rear;</span><br><span class="line">	<span class="keyword">int</span> tag;</span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">	Q.base = (ElemType*) <span class="built_in">malloc</span>(MAXSIZE * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">	<span class="keyword">if</span> (!Q.base) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">	Q.tag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (Q.rear - Q.front + MAXSIZE) % MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Q.rear == Q.front &amp;&amp; Q.tag == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"队列已满"</span>);</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	Q.tag = <span class="number">1</span>;</span><br><span class="line">	Q.base[Q.rear] = e;</span><br><span class="line">	Q.rear = (Q.rear + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Dequeue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Q.rear == Q.front &amp;&amp; Q.tag == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"队列为空"</span>);</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	Q.tag = <span class="number">0</span>;</span><br><span class="line">	e = Q.base[Q.front];</span><br><span class="line">	Q.front = (Q.front + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SqQueue q;</span><br><span class="line">	InitQueue(q);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">		EnQueue(q, i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, QueueLength(q));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">		ElemType t;</span><br><span class="line">		Dequeue(q, t);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分析讨论"><a href="#分析讨论" class="headerlink" title="分析讨论"></a>分析讨论</h3><ol>
<li>时间：使用标志域需要在每次出入队的时候对tag进行赋值；</li>
<li>空间：使用标志域需要给每一个元素开辟另外的内存。<br>综合上述两点，当循环队列容量较小而每一个元素所占空间较多时，使用设标志域的方法可以充分使用内存；而当循环队列容量较大且每个元素所占空间较少时，使用少用一个元素空间的方法相比设标志域的方法可以节省内存。</li>
</ol>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>编程</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>括号匹配</title>
    <url>/2019/10/09/%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>假设一个算术表达式中可以包含三种括号：圆括号’(‘和’)’、方括号’[‘和 ‘]’以及花括号’{‘和’}’。编写判别所给表达式中所含括号是否正确。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>可用“期待匹配消解”的思想来设计算法，对表达式中每一个左括号都期待一个相应的右括号与之匹配，且自左至右按表达式中出现的先后论，越迟的左括号期待匹配的渴望程度越高。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_march</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)str.length(); i++) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (str[i]) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'('</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'['</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'&#123;'</span>: s.push(str[i]); <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">			<span class="keyword">if</span> (s.empty() || s.top() != <span class="string">'('</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				s.pop();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">']'</span>:</span><br><span class="line">			<span class="keyword">if</span> (s.empty() || s.top() != <span class="string">'['</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				s.pop();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">			<span class="keyword">if</span> (s.empty() || s.top() != <span class="string">'&#123;'</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				s.pop();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!s.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) &#123;</span><br><span class="line">		<span class="keyword">if</span> (is_march(s))</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>参考《数据结构（C语言版）》–严蔚敏</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>编程</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>表达式求值</title>
    <url>/2019/09/29/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>表达式求值是一个基本问题，是栈的一个应用。如计算：<br><img src="http://latex.codecogs.com/gif.latex?%5C%7B12*(7-3)#=?%7D" alt=""><br>输入’#’代表结束。</p>
<h3 id="算法基本思想"><a href="#算法基本思想" class="headerlink" title="算法基本思想"></a>算法基本思想</h3><p>使用两个工作栈，一个存运算符(optr)，另一个存操作数或运算结果(opnd)。</p>
<ol>
<li>首先将’#’push到optr；</li>
<li>依次读入每个字符，若是操作数则进opnd（注意多位数情况），若为运算符则于比较optr栈顶运算符比较优先级完成相应操作。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prec</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="string">'+'</span> || a == <span class="string">'-'</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b == <span class="string">'+'</span> || b == <span class="string">'-'</span> || b == <span class="string">')'</span> || b == <span class="string">'#'</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'*'</span> || a == <span class="string">'/'</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b == <span class="string">'('</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'('</span> || a == <span class="string">'#'</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a == <span class="string">'('</span> &amp;&amp; b == <span class="string">')'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'('</span> &amp;&amp; b == <span class="string">'#'</span>) <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'#'</span> &amp;&amp; b == <span class="string">')'</span>) <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'#'</span> &amp;&amp; b == <span class="string">'#'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">')'</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b == <span class="string">'('</span>) <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Operate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">'+'</span>) <span class="keyword">return</span> a + b;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'-'</span>) <span class="keyword">return</span> a - b;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'*'</span>) <span class="keyword">return</span> a * b;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'/'</span>) <span class="keyword">return</span> a / b;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EvaluateExpression</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; optr;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; opnd;</span><br><span class="line">	optr.push(<span class="string">'#'</span>);</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (s[i] != <span class="string">'#'</span> || optr.top() != <span class="string">'#'</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">				num = num * <span class="number">10</span> + (s[i] - <span class="string">'0'</span>);</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			opnd.push(num);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			num = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">switch</span> (prec(optr.top(), s[i])) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">-1</span>: optr.push(s[i]); i++; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>: optr.pop(); i++; <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">char</span> t = optr.top();</span><br><span class="line">				optr.pop();</span><br><span class="line">				<span class="keyword">int</span> b = opnd.top();</span><br><span class="line">				opnd.pop();</span><br><span class="line">				<span class="keyword">int</span> a = opnd.top();</span><br><span class="line">				opnd.pop();</span><br><span class="line">				opnd.push(Operate(a, b, t));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">-2</span>:<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR"</span>; <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> opnd.top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; EvaluateExpression(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考《数据结构（C语言版）》–严蔚敏</p>
</blockquote>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>编程</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构课后作业</title>
    <url>/2019/09/28/chp1%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<blockquote>
<p>请参考《数据结构题集（C语言版）》严慧敏版</p>
</blockquote>
<h3 id="2-11"><a href="#2-11" class="headerlink" title="2.11"></a>2.11</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType *elem;</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">	<span class="keyword">int</span> listsize;</span><br><span class="line">&#125; SqList;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//构造一个空线性表</span></span><br><span class="line">	L.elem = (ElemType*)<span class="built_in">malloc</span>(LIST_INIT_SIZE * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">	<span class="keyword">if</span> (!L.elem) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	L.length = <span class="number">0</span>;</span><br><span class="line">	L.listsize = LIST_INIT_SIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//在顺序线性表L中的第i个位置之前插入新的元素e</span></span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">if</span> (L.length &gt; L.listsize) &#123;</span><br><span class="line">		ElemType *newbase = (ElemType*) <span class="built_in">realloc</span>(L.elem, (L.listsize + LISTINCREMENT) * <span class="keyword">sizeof</span> (ElemType));</span><br><span class="line">		<span class="keyword">if</span> (!newbase) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		L.elem = newbase;</span><br><span class="line">		L.listsize += LISTINCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	ElemType *q = &amp;(L.elem[i - <span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span> (ElemType *p = &amp;(L.elem[L.length - <span class="number">1</span>]); p &gt;= q; --p)</span><br><span class="line">		*(p + <span class="number">1</span>) = *p;</span><br><span class="line">	*q = e;</span><br><span class="line">	L.length++;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InsertOrderList</span><span class="params">(SqList &amp;L, ElemType x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L.length == L.listsize) &#123;</span><br><span class="line">		<span class="keyword">return</span> OVERFLOW;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> i = L.length - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (; i &gt;= <span class="number">0</span> &amp;&amp; x &lt; L.elem[i]; i--);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = L.length - <span class="number">1</span>; j &gt;= i + <span class="number">1</span>; j--) &#123;</span><br><span class="line">			L.elem[j + <span class="number">1</span>] = L.elem[j];</span><br><span class="line">		&#125;</span><br><span class="line">		L.elem[i + <span class="number">1</span>] = x;</span><br><span class="line">		L.length++;</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowSqList</span><span class="params">(SqList L)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">'['</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d,"</span>, *(L.elem + i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d]\n"</span>, *(L.elem + L.length - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqList l;</span><br><span class="line">	InitList_Sq(l);</span><br><span class="line">	ListInsert_Sq(l, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	ListInsert_Sq(l, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	ListInsert_Sq(l, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">	ShowSqList(l);</span><br><span class="line">	InsertOrderList(l, <span class="number">3</span>);</span><br><span class="line">	ShowSqList(l);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-14"><a href="#2-14" class="headerlink" title="2.14"></a>2.14</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFEASIBLE -1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CreateLinkList</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    LinkList head = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">    LinkList end;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    end = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        node* p = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;data);</span><br><span class="line">        end-&gt;next = p;</span><br><span class="line">        end = p;</span><br><span class="line">    &#125;</span><br><span class="line">    end-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    L = head;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (L-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, L-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    CreateLinkList(L, <span class="number">5</span>);</span><br><span class="line">    Show(L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, Length(L));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-19"><a href="#2-19" class="headerlink" title="2.19"></a>2.19</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFEASIBLE -1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CreateLinkList</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    LinkList head = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">    LinkList end;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    end = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        node* p = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;data);</span><br><span class="line">        end-&gt;next = p;</span><br><span class="line">        end = p;</span><br><span class="line">    &#125;</span><br><span class="line">    end-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    L = head;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(LinkList &amp;L, ElemType mink, ElemType maxk)</span> </span>&#123;</span><br><span class="line">    node *p, *p1 = L;</span><br><span class="line">    <span class="keyword">while</span> (p1-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;next-&gt;data &gt; mink &amp;&amp; p1-&gt;next-&gt;data &lt; maxk) &#123;</span><br><span class="line">            p = p1-&gt;next;</span><br><span class="line">            p1-&gt;next = p1-&gt;next-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> p1 = p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (L-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, L-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    CreateLinkList(L, n);</span><br><span class="line">    Show(L);</span><br><span class="line">    Delete(L, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    Show(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="倒置链表"><a href="#倒置链表" class="headerlink" title="倒置链表"></a>倒置链表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFEASIBLE -1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CreateLinkList</span><span class="params">(LinkList &amp;L, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    LinkList head = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">    LinkList end;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    end = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        node* p = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;data);</span><br><span class="line">        end-&gt;next = p;</span><br><span class="line">        end = p;</span><br><span class="line">    &#125;</span><br><span class="line">    end-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    L = head;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ReverseLinkList</span><span class="params">(LinkList &amp;L)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span> || L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    node *prev = L;</span><br><span class="line">    node *cur = L-&gt;next;</span><br><span class="line">    node *tmp = L-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">        tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next = prev;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (L-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, L-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    CreateLinkList(L, n);</span><br><span class="line">    Show(L);</span><br><span class="line">    ReverseLinkList(L);</span><br><span class="line">    Show(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>一道简单题</title>
    <url>/2019/09/22/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E9%A2%98(Easy_Problem_from_Rujia_Liu?UVa_11991)/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给出一个包含n个整数的数组，你需要回答若干询问。每次询问两个整数k和v，输出从左到右第k个v的下标(数组从1～n编号)。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>多组数据。每组数据第一行为n和m(1 &lt;= n, m &lt;= 100000)，第二行为n个整数(n不超过1e6)；以下m行每行为k和v。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个查询，输出查询结果。若不存在，输出0。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, x, y;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">			<span class="keyword">if</span> (!a.count(x))</span><br><span class="line">				a[x] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">			a[x].push_back(i + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">			<span class="keyword">if</span> (a.count(y) || (<span class="keyword">int</span>)a[y].size() &gt;= x)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[y][x<span class="number">-1</span>]);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>预处理每个元素时间复杂度为O(logn)(map查找)，总时间复杂度为O(nlogn)。</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>抽象数据类型(ADT)</tag>
      </tags>
  </entry>
  <entry>
    <title>用C语言实现静态链表</title>
    <url>/2019/09/20/%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>用数组替代指针，数组中的每一项有两个域：data &amp; cur；data用来存放数据，而cur则为游标，相当于链表中的next。<br><img src="/img/space.png"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE       1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE      0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK         1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR      0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFEASIBLE -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW   -2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">int</span> cur;</span><br><span class="line">&#125; Component, StaticLinkList[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将下标为k的空闲结点回收到备用链表*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free_SSL</span><span class="params">(StaticLinkList space, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	space[k].cur = space[<span class="number">0</span>].cur;</span><br><span class="line">	space[<span class="number">0</span>].cur = k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(StaticLinkList L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = L[MAXSIZE<span class="number">-1</span>].cur;</span><br><span class="line">	<span class="keyword">while</span> (i) &#123;</span><br><span class="line">		i = L[i].cur;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(StaticLinkList space)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXSIZE - <span class="number">1</span>; i++)</span><br><span class="line">		space[i].cur = i + <span class="number">1</span>;</span><br><span class="line">	space[MAXSIZE<span class="number">-1</span>].cur = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*若备用空间链表非空，则返回分配的结点的下标，否则返回0*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Malloc_SLL</span><span class="params">(StaticLinkList space)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = space[<span class="number">0</span>].cur;</span><br><span class="line">	<span class="keyword">if</span> (space[<span class="number">0</span>].cur)</span><br><span class="line">		space[<span class="number">0</span>].cur = space[i].cur;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在L中第i个元素之前插入新的数据元素e*/</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j, k, l;</span><br><span class="line">	k = MAXSIZE - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; ListLength(L) + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	j = Malloc_SLL(L);</span><br><span class="line">	<span class="keyword">if</span> (j) &#123;</span><br><span class="line">		L[j].data = e;</span><br><span class="line">		<span class="keyword">for</span> (l = <span class="number">1</span>; l &lt;= i - <span class="number">1</span>; l++) &#123;</span><br><span class="line">			k = L[k].cur;</span><br><span class="line">		&#125;</span><br><span class="line">		L[j].cur = L[k].cur;</span><br><span class="line">		L[k].cur = j;</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除在L中第i个元素e*/</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j, k;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; ListLength(L))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	k = MAXSIZE - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> ( j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)</span><br><span class="line">		k = L[k].cur;</span><br><span class="line">	j = L[k].cur;</span><br><span class="line">	L[k].cur = L[j].cur;</span><br><span class="line">	Free_SSL(L, j);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	StaticLinkList l;</span><br><span class="line">	InitList(l);</span><br><span class="line">	ListInsert(l, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l[<span class="number">1</span>].data);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点：增删结点时不需要移动；</li>
<li>缺点：不能动态存取。</li>
</ul>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>简单双向循环链表的表示和实现(C语言)</title>
    <url>/2019/09/15/%E7%AE%80%E5%8D%95%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0(C%E8%AF%AD%E8%A8%80)/</url>
    <content><![CDATA[<h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><p>双向链表的每一个节点有两个指针，一个是next（下一个），一个是prep（上一个），其他和单向类似；至于循环双向链表，它的结构为：<br><img src="https://img-blog.csdn.net/20140224081224125"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE       1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE      0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK         1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR      0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFEASIBLE -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW   -2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTINCREMENT  10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType value;</span><br><span class="line">	Node* prep;</span><br><span class="line">	Node* next;</span><br><span class="line">&#125; DbLink;</span><br><span class="line"></span><br><span class="line"><span class="function">DbLink* <span class="title">CreateDbLink</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	DbLink *head, *node, *<span class="built_in">end</span>;</span><br><span class="line">	head = (DbLink*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DbLink));</span><br><span class="line">	<span class="keyword">if</span> (!head) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	<span class="built_in">end</span> = head;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		node = (DbLink*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DbLink));</span><br><span class="line">		<span class="keyword">if</span> (!node) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;node-&gt;value);</span><br><span class="line">		node-&gt;prep = <span class="built_in">end</span>;</span><br><span class="line">		<span class="built_in">end</span>-&gt;next = node;</span><br><span class="line">		<span class="built_in">end</span> = node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">end</span>-&gt;next = head;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">(DbLink *h)</span> </span>&#123;</span><br><span class="line">	DbLink* tmp = h;</span><br><span class="line">	<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (h-&gt;next != tmp) &#123;</span><br><span class="line">		h = h-&gt;next;</span><br><span class="line">		length++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowDblink</span><span class="params">(DbLink *h)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"["</span>);</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> len = GetLength(h);</span><br><span class="line">	<span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">		i++;</span><br><span class="line">		h = h-&gt;next;</span><br><span class="line">		<span class="built_in">printf</span>(i == len ? <span class="string">"%d]\n"</span> : <span class="string">"%d "</span>, h-&gt;value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InsertElem</span><span class="params">(DbLink *h, <span class="keyword">int</span> pos, ElemType v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos &gt; <span class="number">0</span> &amp;&amp; pos &lt;= GetLength(h)) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pos; i++)</span><br><span class="line">			h = h-&gt;next;</span><br><span class="line">		DbLink* node = (DbLink*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DbLink));</span><br><span class="line">		<span class="keyword">if</span> (!node) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		DbLink* tmp = <span class="literal">NULL</span>;</span><br><span class="line">		node-&gt;value = v;</span><br><span class="line">		tmp = h-&gt;next;</span><br><span class="line">		node-&gt;prep = h;</span><br><span class="line">		h-&gt;next = node;</span><br><span class="line">		node-&gt;next = tmp;</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	DbLink* h = CreateDbLink(<span class="number">5</span>);</span><br><span class="line">	ShowDblink(h);</span><br><span class="line">	InsertElem(h, <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">	ShowDblink(h);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>归并两个非递减排列的线性表(C语言)</title>
    <url>/2019/09/12/%E5%BD%92%E5%B9%B6%E4%B8%A4%E4%B8%AA%E9%9D%9E%E9%80%92%E5%87%8F%E6%8E%92%E5%88%97%E7%9A%84%E7%BA%BF%E6%80%A7%E8%A1%A8(C%E8%AF%AD%E8%A8%80)/</url>
    <content><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>已知线性表La, Lb按非递减有序排列，现需要将La, Lb归并为一个新的非递减有序排列线性表Lc。例如</p>
<blockquote>
<p>La = (3, 5, 8, 11)<br>Lb = (2, 6, 8, 20)<br>则Lc = (2, 3, 5, 6, 8, 8,11, 20)</p>
</blockquote>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>设两个指针pa, pb分别指向La，Lb的首元素，当前应插入Lc的元素为<a href="https://www.codecogs.com/eqnedit.php?latex=c=\left\{\begin{matrix}&space;a,&space;a&space;\leqslant&space;b\\&space;b,&space;a>b&space;\end{matrix}\right." target="_blank"><img src="https://latex.codecogs.com/gif.latex?c=\left\{\begin{matrix}&space;a,&space;a&space;\leqslant&space;b\\&space;b,&space;a>b&space;\end{matrix}\right." title="c=\left\{\begin{matrix} a, a \leqslant b\\ b, a>b \end{matrix}\right." /></a></p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>显然该算法为线性复杂度，即O(n)；原因是La, Lb为非递减有序排列，故lb中的每个元素不必遍历la中每个元素；而且Lc插入操作实则是通过复制完成的。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE       1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE      0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK         1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR      0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFEASIBLE -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW   -2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTINCREMENT  10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType *elem;</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">	<span class="keyword">int</span> listsize;</span><br><span class="line">&#125; SqList;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//构造一个空线性表</span></span><br><span class="line">	L.elem = (ElemType*)<span class="built_in">malloc</span>(LIST_INIT_SIZE * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">	<span class="keyword">if</span> (!L.elem) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	L.length = <span class="number">0</span>;</span><br><span class="line">	L.listsize = LIST_INIT_SIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//在顺序线性表L中的第i个位置之前插入新的元素e</span></span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">if</span> (L.length &gt; L.listsize) &#123;</span><br><span class="line">		ElemType *newbase = (ElemType*) <span class="built_in">realloc</span>(L.elem, (L.listsize + LISTINCREMENT) * <span class="keyword">sizeof</span> (ElemType));</span><br><span class="line">		<span class="keyword">if</span> (!newbase) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		L.elem = newbase;</span><br><span class="line">		L.listsize += LISTINCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	ElemType *q = &amp;(L.elem[i - <span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span> (ElemType *p = &amp;(L.elem[L.length - <span class="number">1</span>]); p &gt;= q; --p)</span><br><span class="line">		*(p + <span class="number">1</span>) = *p;</span><br><span class="line">	*q = e;</span><br><span class="line">	L.length++;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeList_Sq</span><span class="params">(SqList La, SqList Lb, SqList &amp;Lc)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//La, Lb非递减排列，归并后得到非递减排列的Lc</span></span><br><span class="line">	ElemType* pa = La.elem;</span><br><span class="line">	ElemType* pb = Lb.elem;</span><br><span class="line">	Lc.listsize = Lc.length = La.length + Lb.length;</span><br><span class="line">	ElemType* pc = Lc.elem = (ElemType*)<span class="built_in">malloc</span>(Lc.listsize * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">	<span class="keyword">if</span> (!Lc.elem) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	ElemType* pa_last = La.elem + La.length - <span class="number">1</span>;</span><br><span class="line">	ElemType* pb_last = Lb.elem + Lb.length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*pa &lt;= *pb)</span><br><span class="line">			*pc++ = *pa++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			*pc++ = *pb++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (pa &lt;= pa_last) *pc++ = *pa++;</span><br><span class="line">	<span class="keyword">while</span> (pb &lt;= pb_last) *pc++ = *pb++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowList_Sq</span><span class="params">(SqList L)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"["</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, *(L.elem + i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, *(L.elem + L.length - <span class="number">1</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"]\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqList la, lb, lc;</span><br><span class="line">	InitList_Sq(la);</span><br><span class="line">	InitList_Sq(lb);</span><br><span class="line">	InitList_Sq(lc);</span><br><span class="line">	ListInsert_Sq(la, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	ListInsert_Sq(la, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"la:\n"</span>);</span><br><span class="line">	ShowList_Sq(la);</span><br><span class="line">	ListInsert_Sq(lb, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	ListInsert_Sq(lb, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	ListInsert_Sq(lb, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"lb:\n"</span>);</span><br><span class="line">	ShowList_Sq(lb);</span><br><span class="line">	MergeList_Sq(la, lb, lc);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"lc:\n"</span>);</span><br><span class="line">	ShowList_Sq(lc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表的顺序表示和实现(C语言)</title>
    <url>/2019/09/07/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0(C%E8%AF%AD%E8%A8%80)/</url>
    <content><![CDATA[<h3 id="线性表的顺序表示"><a href="#线性表的顺序表示" class="headerlink" title="线性表的顺序表示:"></a>线性表的顺序表示:</h3><ul>
<li>线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素。</li>
<li>数据元素的存储位置之间满足如下关系:<br><img src="http://latex.codecogs.com/gif.latex?%5C%7BLOC(a_%7Bi+1%7D)=LOC(a_i)%7D+l" alt=""></li>
<li>一般来说:<br><img src="http://latex.codecogs.com/gif.latex?%5C%7BLOC(a_i)=LOC(a_1)+(i-1)Xl%7D" alt=""><br><img src="http://img.wandouip.com/crawler/article/201978/ef79eb5bdf382d3d2e955ab5fc53680c" alt=""><h3>代码实现:</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE       1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE      0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK         1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR      0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFEASIBLE -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW   -2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTINCREMENT  10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	ElemType *elem;</span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">	<span class="keyword">int</span> listsize;</span><br><span class="line">&#125; SqList;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//构造一个空线性表</span></span><br><span class="line">	L.elem = (ElemType*)<span class="built_in">malloc</span>(LIST_INIT_SIZE * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">	<span class="keyword">if</span> (!L.elem) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	L.length = <span class="number">0</span>;</span><br><span class="line">	L.listsize = LIST_INIT_SIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//在顺序线性表L中的第i个位置之前插入新的元素e</span></span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">if</span> (L.length &gt; L.listsize) &#123;</span><br><span class="line">		ElemType *newbase = (ElemType*) <span class="built_in">realloc</span>(L.elem, (L.listsize + LISTINCREMENT) * <span class="keyword">sizeof</span> (ElemType));</span><br><span class="line">		<span class="keyword">if</span> (!newbase) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		L.elem = newbase;</span><br><span class="line">		L.listsize += LISTINCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	ElemType *q = &amp;(L.elem[i - <span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span> (ElemType *p = &amp;(L.elem[L.length - <span class="number">1</span>]); p &gt;= q; --p)</span><br><span class="line">		*(p + <span class="number">1</span>) = *p;</span><br><span class="line">	*q = e;</span><br><span class="line">	L.length++;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ListDelete_Sq</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//删除线性表L中第i个元素并将该元素储存在e中</span></span><br><span class="line">	<span class="keyword">if</span> ((i &lt; <span class="number">1</span>) || (i &gt; L.length)) <span class="keyword">return</span> ERROR;</span><br><span class="line">	ElemType *p = &amp;(L.elem[i - <span class="number">1</span>]);</span><br><span class="line">	e = *p;</span><br><span class="line">	ElemType *q = L.elem + L.length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (++p; p &lt;= q; ++ p)</span><br><span class="line">		*(p - <span class="number">1</span>) = *p;</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowSqList</span><span class="params">(SqList L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *(L.elem + i));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SqList l;</span><br><span class="line">	InitList_Sq(l);</span><br><span class="line">	ListInsert_Sq(l, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	ListInsert_Sq(l, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	ListInsert_Sq(l, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">	ShowSqList(l);</span><br><span class="line">	ElemType tmp;</span><br><span class="line">	ListDelete_Sq(l, <span class="number">2</span>, tmp);</span><br><span class="line">	ShowSqList(l);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tmp);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
### 注释:
参考《数据结构（C语言版）--严蔚敏
</li>
</ul>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>求两个简单链表的并集</title>
    <url>/2019/09/07/%E6%B1%82%E4%B8%A4%E4%B8%AA%E7%AE%80%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
    <content><![CDATA[<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>给出两个单向链表，求出它们的并集<br>例如：</p>
<blockquote>
<p>a = [1, 2, 3], b = [2, 3, 4]; 实现InterSect(a, b), 使得a = [1, 2, 3, 4]</p>
</blockquote>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	node *next;</span><br><span class="line">&#125; LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList* <span class="title">InitList</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	LinkList *head, *node, *<span class="built_in">end</span>;</span><br><span class="line">	head = <span class="keyword">new</span> LinkList;</span><br><span class="line">	<span class="built_in">end</span> = head;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		node = <span class="keyword">new</span> LinkList;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;node-&gt;value);</span><br><span class="line">		<span class="built_in">end</span>-&gt;next = node;</span><br><span class="line">		<span class="built_in">end</span> = node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">end</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowList</span><span class="params">(LinkList *h)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (h-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		h = h-&gt;next;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, h-&gt;value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(LinkList *h, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	LinkList *node = <span class="keyword">new</span> LinkList;</span><br><span class="line">	<span class="keyword">while</span> (h-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">		h = h-&gt;next;</span><br><span class="line">	node-&gt;value = v;</span><br><span class="line">	h-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InterSect</span><span class="params">(LinkList *a, LinkList *b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (b-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		LinkList *A = a;</span><br><span class="line">		b = b-&gt;next;</span><br><span class="line">		<span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (A-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			A = A-&gt;next;</span><br><span class="line">			<span class="keyword">if</span> (A-&gt;value == b-&gt;value) &#123;</span><br><span class="line">				flag = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp = b-&gt;value;</span><br><span class="line">		<span class="keyword">if</span> (flag)</span><br><span class="line">			Insert(a, tmp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	LinkList *a = InitList(n);</span><br><span class="line">	LinkList *b = InitList(n);</span><br><span class="line">	ShowList(a);</span><br><span class="line">	ShowList(b);</span><br><span class="line">	InterSect(a, b);</span><br><span class="line">	ShowList(a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>一个用C实现的简单的单向链表</title>
    <url>/2019/09/04/%E4%B8%80%E4%B8%AA%E7%94%A8C%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-2019/</url>
    <content><![CDATA[<h3>下面是一个简单的链表</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">value</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">value</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList *<span class="title">create</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	LinkList *head, *node, *<span class="built_in">end</span>;</span><br><span class="line">	head = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">	<span class="built_in">end</span> = head;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		node = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;node-&gt;v);</span><br><span class="line">		<span class="built_in">end</span>-&gt;next = node;</span><br><span class="line">		<span class="built_in">end</span> = node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">end</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(LinkList *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	LinkList *t = <span class="built_in">list</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; n &amp;&amp; t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		t = t-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"输入要修改的值"</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t-&gt;v);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"结点不存在"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delet</span><span class="params">(LinkList *<span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	LinkList *t = <span class="built_in">list</span>, *in;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; n &amp;&amp; t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		in = t;</span><br><span class="line">		t = t-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		in-&gt;next = t -&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(t);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"结点不存在"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(LinkList *<span class="built_in">list</span>, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">	LinkList *t = <span class="built_in">list</span>, *in;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; n &amp;&amp; t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		t = t-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125; <span class="keyword">if</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		in = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">		in-&gt;v = value;</span><br><span class="line">		in-&gt;next = t-&gt;next;</span><br><span class="line">		t-&gt;next = in;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"结点不存在"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(LinkList *h)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(h-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		h = h-&gt;next;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, h-&gt;v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	LinkList *h = create(n);</span><br><span class="line">	show(h);</span><br><span class="line">	insert(h, <span class="number">3</span>, <span class="number">9</span>);</span><br><span class="line">	show(h);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>一个简单的位运算及其复杂度分析(Sample)</title>
    <url>/2019/09/03/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97%E5%8F%8A%E5%85%B6%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90(Sample)-2019/</url>
    <content><![CDATA[<h4>问题：</h4>
对于任意非负整数,统计其二进制展开中数位1的总数。
#### 方法：
将n与1位与，若结果为1则将计数器+1，之后将n向右移一位，重复上述过程直至n缩减为0；
例如：
>5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0101
3转换为二进制：0000 0000 0000 0000 0000 0000 0000 0011
1转换为二进制：0000 0000 0000 0000 0000 0000 0000 0001
故 5 & 3 = 1
（位与：第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为0）

<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOnes</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ones = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(n) &#123;</span><br><span class="line">		ones += n &amp; <span class="number">1</span>;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; countOnes(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h4><p>总的循环次数为n展开为二进制后的位数，即<a href="https://camo.githubusercontent.com/495a5da7a52dcf738f11295a5fd2026113af08ac/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f31202b206c6f675f326e" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/495a5da7a52dcf738f11295a5fd2026113af08ac/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f31202b206c6f675f326e" alt="img"></a>无论是该循环体之前、之内还是之后,均只涉及常数次(逻辑判断、位与运算、加法、右移 等)基本操作。因此,countOnes()算法的执行时间主要由循环的次数决定,亦即: <a href="https://camo.githubusercontent.com/0a83de70ba46caa59193b5a41f357c1f0d73a993/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f4f28312b5b6c6f675f326e5d293d4f285b6c6f675f326e5d293d4f286c6f675f326e29" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/0a83de70ba46caa59193b5a41f357c1f0d73a993/687474703a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f4f28312b5b6c6f675f326e5d293d4f285b6c6f675f326e5d293d4f286c6f675f326e29" alt="img"></a> 由大O记号定义,在用函数log r n界定渐进复杂度时,常底数r的具体取值无所谓，故通常不予专门标出而笼统地记作logn，比如,尽管此处底数为常数2,却可直接记作O(logn)。此类算法称作具有“对数时间复杂度”(logarithmic-time algorithm)。</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>求k阶斐波那契第m项的值</title>
    <url>/2019/09/03/%E6%B1%82k%E9%98%B6%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E7%AC%ACm%E9%A1%B9%E7%9A%84%E5%80%BC-2019/</url>
    <content><![CDATA[<h3>问题描述</h3>
已知k阶斐波那契序列的定义为[![f_0 = 0, f_1 = 0, ...,f_{k-2}=0,f_{k-1}=1;](https://camo.githubusercontent.com/9eea781d995259c8387c9606dba822404466ae1e/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f665f302673706163653b3d2673706163653b302c2673706163653b665f312673706163653b3d2673706163653b302c2673706163653b2e2e2e2c665f7b6b2d327d3d302c665f7b6b2d317d3d313b)](https://www.codecogs.com/eqnedit.php?latex=f_0&space;=&space;0,&space;f_1&space;=&space;0,&space;...,f_{k-2}=0,f_{k-1}=1;) [![f_n = f_{n-1}+f_{n-2}+...+f_{n-k},n=k,k+1,...](https://camo.githubusercontent.com/481c0d1a44a760179c6158ddf2e3c3ae5650a3c6/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f665f6e2673706163653b3d2673706163653b665f7b6e2d317d2b665f7b6e2d327d2b2e2e2e2b665f7b6e2d6b7d2c6e3d6b2c6b2b312c2e2e2e)](https://www.codecogs.com/eqnedit.php?latex=f_n&space;=&space;f_{n-1}+f_{n-2}+...+f_{n-k},n=k,k+1,...)试编写求k阶斐波那契数列第m项值的算法，k和m均以值调用的形式在函数列表出现。

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> a[MAXN];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		a[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	a[k - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> s = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; i - <span class="number">1</span> - k; j--) &#123;</span><br><span class="line">			s += a[j];</span><br><span class="line">		&#125;</span><br><span class="line">		a[i] = s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a[m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k, m;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;k, &amp;m) == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, fib(k, m));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>该题目出现在数据结构（C语言版）题集中的1.17</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>C</tag>
      </tags>
  </entry>
</search>
